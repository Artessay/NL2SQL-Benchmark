  SELECT MAX(`Free Meal Count  (K-12)` / `Enrollment  (K-12)`) AS eligible_free_rate FROM `frpm` WHERE `County Name` = 'Alameda';
SELECT `Educational Option Type`, `Enrollment  (Ages 5-17)`, `Free Meal Count  (Ages 5-17)`,         CASE WHEN `Enrollment  (Ages 5-17)` != 0 THEN (`Free Meal Count  (Ages 5-17)` / `Enrollment  (Ages 5-17)`) ELSE NULL END AS eligible_free_rate FROM frpm WHERE `Educational Option Type` = 'Traditional' ORDER BY eligible_free_rate ASC LIMIT 3; 
SELECT `Zip` FROM `schools`  JOIN `frpm` ON `schools`.`CDSCode` = `frpm`.`CDSCode`  WHERE `District Name` = 'Fresno County Office of Education' AND `Charter School (Y/ N)` = 1; 
SELECT schools.MailStreet  FROM frpm  INNER JOIN schools ON frpm.CDSCode = schools.CDSCode  ORDER BY `frpm Count (K-12)` DESC  LIMIT 1; 
SELECT s.Phone  FROM schools s  INNER JOIN frpm f ON s.CDSCode = f.CDSCode  WHERE f.`Charter School (Y/ N)` = 1 AND s.OpenDate >= '2000-01-01'; 
  SELECT COUNT(*) FROM `schools`  JOIN `satscores` ON `schools`.`CDSCode` = `satscores`.`cds`  WHERE `satscores`.`AvgScrMath` > 400 AND `schools`.`Virtual` = 'F';
SELECT s.School  FROM schools s  JOIN satscores ss ON s.CDSCode = ss.cds  WHERE ss.NumTstTakr > 500 AND s.Magnet = 1; 
SELECT schools.Phone  FROM satscores  INNER JOIN schools ON satscores.cds = schools.CDSCode  WHERE satscores.NumGE1500 IS NOT NULL  ORDER BY satscores.NumGE1500 DESC  LIMIT 1; 
WITH max_frpm AS (     SELECT MAX(frpm_value) as max_val     FROM frpm ), max_schools AS (     SELECT CDSCode     FROM frpm     WHERE frpm_value = (SELECT max_val FROM max_frpm) ) SELECT s.NumTstTakr FROM max_schools ms JOIN satscores s ON ms.CDSCode = s.cds; 
  SELECT COUNT(*)  FROM frpm f  JOIN satscores s ON f.CDSCode = s.cds  WHERE `Charter Funding Type` = 'Directly funded' AND `AvgScrMath` > 560;
  SELECT frpm."FRPM Count  (Ages 5-17)"  FROM satscores  JOIN frpm ON TRIM(satscores.cds) = TRIM(frpm.CDSCode)  WHERE AvgScrRead = (     SELECT MAX(AvgScrRead)      FROM satscores );
  SELECT `CDSCode` FROM `frpm` WHERE `Enrollment (K-12)` + `Enrollment (Ages 5-17)` > 500;
SELECT MAX(free_meal_count / enrollment) AS max_free_rate FROM frpm f JOIN satscores s ON f.CDSCode = s.cds WHERE (s.NumGE1500 / s.NumTstTakr) > 0.3; 
  SELECT DISTINCT schools.Phone FROM satscores  JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.Phone IS NOT NULL ORDER BY (satscores.NumGE1500 / NULLIF(COALESCE(satscores.NumTstTakr, 0), 0)) DESC LIMIT 3;
SELECT s.NCESSchool, f.`Enrollment (Ages 5-17)` FROM `frpm` f INNER JOIN `schools` s ON f.CDSCode = s.CDSCode ORDER BY f.`Enrollment (Ages 5-17)` DESC LIMIT 5; 
SELECT sc.District, AVG(s.AvgScrRead) AS avg_score FROM satscores s JOIN schools sc ON s.cds = sc.CDSCode WHERE sc.StatusType = 'Active' GROUP BY sc.District ORDER BY avg_score DESC LIMIT 1; 
SELECT COUNT(*)  FROM satscores  INNER JOIN schools ON satscores.cds = schools.CDSCode  WHERE schools.County = 'Alameda' AND satscores.NumTstTakr < 100; 
SELECT      DENSE_RANK() OVER (ORDER BY `AvgScrWrite` DESC) AS Rank,     `satscores`.`cds`,     `AvgScrWrite`,     `schools`.`CharterNum` FROM      `satscores` JOIN      `schools` ON `satscores`.`cds` = `schools`.`CDSCode` WHERE      `AvgScrWrite` > 499 AND `schools`.`CharterNum` IS NOT NULL ORDER BY      `AvgScrWrite` DESC; 
SELECT COUNT(*)  FROM schools s  JOIN satscores ss ON s.CDSCode = ss.cds  WHERE s.County = 'Fresno' AND s.FundingType = 'Directly funded' AND ss.NumTstTakr <= 250; 
SELECT sch.Phone FROM schools sch WHERE sch.CDSCode IN (     SELECT cds     FROM satscores s     WHERE s.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores) ); 
SELECT COUNT(frpm.CDSCode) FROM frpm  INNER JOIN schools ON frpm.CDSCode = schools.CDSCode  WHERE schools.County = 'Amador' AND frpm.LowGrade = '9' AND frpm.HighGrade = '12'; 
  SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `Free Meal Count (K-12)` < 700;
SELECT sname, NumTstTakr FROM satscores WHERE cname = 'Contra Costa' ORDER BY NumTstTakr DESC LIMIT 1; 
SELECT s.School AS SchoolName, s.StreetAbr AS StreetAddress  FROM frpm f  JOIN schools s ON f.CDSCode = s.CDSCode  WHERE ABS(f.EnrollmentK12 - f.EnrollmentAges5_17) > 30; 
SELECT cds, math_score, reading_score FROM satscores WHERE math_score > 50 AND reading_score > 50; 
python import pandas as pd  # Assuming frpm_df and satscores_df are DataFrames containing the respective data  # Step 1: Join the two DataFrames on CDSCode = cds where cds is not NULL merged_df = frpm_df.merge(satscores_df, left_on='CDSCode', right_on='cds', how='inner').dropna(subset=['cds'])  # Step 2: Filter for schools in Riverside district riverside_schools = merged_df[merged_df['District Name'] == 'Riverside']  # Step 3: Check if AvgScrMath is greater than 400 and select relevant columns high_scorers = riverside_schools[riverside_schools['AvgScrMath'] > 400][['CDSCode', ' District Name', 'Funding Type']]  # Display the result print(high_scorers) 
SELECT      s.`School Name`,     s.Street,     s.City,     s.State,     s.Zip FROM      frpm f JOIN      schools s ON f.CDSCode = s.CDSCode WHERE      s.County = 'Monterey'      AND f.`School Type` = 'High School'     AND f.`Free Meal Count (Ages 5-17)` > 800; 
SELECT s.School, s.Phone, sa.AvgScrWrite  FROM schools s  JOIN satscores sa ON s.CDSCode = sa.cds  WHERE (s.OpenDate > '1991-01-01' OR s.ClosedDate < '2000-01-01'); 
  WITH avg_diff AS (     SELECT          AVG(`Enrollment  (K-12)` - `Enrollment  (Ages 5-17)`) AS avg_enroll_diff     FROM          frpm          JOIN schools USING (`CDSCode`)     WHERE          FundingType = 'Locally Funded' ) SELECT      s.School,      s.DOC,     f.`Enrollment  (K-12)` - f.`Enrollment  (Ages 5-17)` AS difference FROM      frpm f     JOIN schools s USING (`CDSCode`) WHERE      s.FundingType = 'Locally Funded' AND     (f.`Enrollment  (K-12)` - f.`Enrollment  (Ages 5-17)`) > (         SELECT avg_enroll_diff FROM avg_diff     ) ORDER BY difference DESC;
SELECT schools.OpenDate  FROM frpm  JOIN schools ON frpm.CDSCode = schools.CDSCode  ORDER BY `Enrollment (K-12)` DESC  LIMIT 1; 
SELECT s.City, SUM(f.Enrollment) AS TotalEnrollment FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode GROUP BY s.City ORDER BY TotalEnrollment ASC LIMIT 5; 
  WITH cte AS (     SELECT `Enrollment  (K-12)`, `Free Meal Count  (K-12)`,            ROW_NUMBER() OVER (ORDER BY `Enrollment  (K-12)` DESC) AS rn     FROM frpm ) SELECT (`Free Meal Count  (K-12)` / `Enrollment  (K-12)`) AS eligible_free_rate FROM cte WHERE rn IN (10, 11);
SELECT schools.*, (frpm.`FRPM Count (K-12)` / frpm.`Enrollment (K-12)`) AS eligible_rate  FROM frpm  JOIN schools ON frpm.CDSCode = schools.CDSCode  WHERE schools.SOC = '66'  ORDER BY frpm.`FRPM Count (K-12)` DESC  LIMIT 5; 
  SELECT `frpm`.`School Name`, `schools`.`Website`  FROM `frpm`  JOIN `schools` ON `frpm`.`CDSCode` = `schools`.`CDSCode`  WHERE `frpm`.`Free Meal Count (Ages 5-17)` >= 1900 AND `frpm`.`Free Meal Count (Ages 5-17)` <= 2000;
  SELECT (f.`Free Meal Count  (Ages 5-17)` / f.`Enrollment (Ages 5-17)`) AS Free_Rate, s.AdmFName1, s.AdmLName1   FROM `frpm` f   JOIN `schools` s ON f.CDSCode = s.CDSCode   WHERE s.AdmFName1 LIKE '%Kacey%' AND s.AdmLName1 LIKE '%Gibson%';
SELECT `AdmEmail1`  FROM `frpm`  JOIN `schools` ON `frpm`.`CDSCode` = `schools`.`CDSCode`  WHERE `Charter School (Y/NN)` = 1  ORDER BY `Enrollment (K-12)` ASC  LIMIT 1; 
SELECT      AdmFName1 ASFirstName,     AdmLName1 ASLastName,     AdmFName2 ASFirstName,     AdmLName2 ASLastName,     AdmFName3 ASFirstName,     AdmLName3 ASLastName FROM schools WHERE CDSCode IN (     SELECT cds      FROM satscores      WHERE NumGE1500 = (         SELECT MAX(NumGE1500)          FROM satscores     ) ); 
SELECT      Street, City, State, Zip,     (NumGE1500 / NumTstTakr) AS ExcellenceRate FROM      satscores JOIN      schools ON satscores.cds = schools.CDSCode WHERE      NumTstTakr IS NOT NULL AND NumTstTakr > 0 ORDER BY      ExcellenceRate ASC, cds LIMIT 1; 
  SELECT `Website` FROM `schools` INNER JOIN `satscores` ON `schools`.`CDSCode` = `satscores`.`cds` WHERE `County` = 'Los Angeles' AND `NumTstTakr` BETWEEN 2000 AND 3000;
  SELECT AVG(ss.NumTstTakr) FROM satscores ss JOIN schools sc ON ss.cds = sc.CDSCode WHERE sc.County = 'Fresno' AND sc.OpenDate >= '1980-01-01' AND sc.OpenDate <= '1980-12-31';
  SELECT Phone FROM satscores JOIN schools ON cds = CDSCode WHERE District = 'Fresno Unified' ORDER BY AvgScrRead ASC LIMIT 1;
WITH ranked_schools AS (     SELECT          s.School,         ss.AvgScrRead,         s.County,         RANK() OVER (PARTITION BY s.County ORDER BY ss.AvgScrRead DESC) as score_rank     FROM          schools s     JOIN          satscores ss ON s.CDSCode = ss.cds     WHERE          s.Virtual = 'F' ) SELECT      School  FROM      ranked_schools  WHERE      score_rank <= 5; 
SELECT schools.EdOpsName FROM schools JOIN satscores ON schools.CDSCode = satscores.cds WHERE satscores.AvgScrMath = (     SELECT MAX(AvgScrMath)     FROM satscores ); 
SELECT s.AvgScrMath AS AvgMathScore, sch.County  FROM satscores s  JOIN schools sch ON s.cds = sch.CDSCode  WHERE s.AvgScrRead IS NOT NULL AND s.AvgScrMath IS NOT NULL AND s.AvgScrWrite IS NOT NULL  ORDER BY (s.AvgScrRead + s.AvgScrMath + s.AvgScrWrite) ASC  LIMIT 1; 
  SELECT satscores.AvgScrWrite, schools.City FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores);
  SELECT schools.School, satscores.AvgScrWrite FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.AdmFName1 = 'Ricci' AND schools.AdmLName1 = 'Ulrich' GROUP BY schools.School;
  SELECT School, `Enrollment (K-12)` FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.DOC = '31' ORDER BY `Enrollment (K-12)` DESC;
  SELECT COUNT(*) / 12 AS MonthlyAverage FROM schools WHERE County = 'Alameda' AND DOC = '52' AND YEAR(OpenDate) = 1980;
SELECT      COUNT(CASE WHEN DOC = 54 THEN 1 END) AS unified_count,     COUNT(CASE WHEN DOC = 52 THEN 1 END) AS elementary_count,     (COUNT(CASE WHEN DOC = 54 THEN 1 END) / COUNT(CASE WHEN DOC = 52 THEN 1 END)) AS ratio FROM      schools WHERE      County = 'Orange'; 
WITH CountyCounts AS (     SELECT          County,         COUNT(*) as ClosedCount,         RANK() OVER (ORDER BY COUNT(*) DESC) as CountyRank     FROM          schools     WHERE          StatusType = 'Closed'     GROUP BY          County ) SELECT      c.County,      s.School,      s.ClosedDate FROM      schools s JOIN      CountyCounts c ON s.County = c.County AND c.CountyRank = 1 WHERE      s.StatusType = 'Closed' ORDER BY      c.County; 
SELECT schools.MailStreet AS Postal_Street_Address, satscores.sname AS School_Name  FROM satscores  JOIN schools ON satscores.cds = schools.CDSCode  WHERE AvgScrMath IS NOT NULL AND satscores.cds IN (     SELECT cds FROM satscores WHERE AvgScrMath IS NOT NULL ORDER BY AvgScrMath DESC LIMIT 7 OFFSET 6 ); 
  SELECT School, MailStreet   FROM satscores   JOIN schools ON satscores.cds = schools.CDSCode   WHERE AvgScrRead IS NOT NULL   ORDER BY AvgScrRead ASC   LIMIT 1;
SELECT COUNT(*)  FROM satscores  JOIN schools ON satscores.cds = schools.CDSCode  WHERE (COALESCE(AvgScrRead, 0) + COALESCE(AvgScrMath, 0) + COALESCE(AvgScrWrite, 0)) >= 1500  AND MailCity = 'Lakeport'; 
  SELECT SUM(s.NumTstTakr) FROM satscores s INNER JOIN schools sch ON s.cds = sch.CDSCode WHERE sch.MailCity = 'Fresno';
  SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';
  SELECT (SELECT COUNT(*) FROM schools WHERE County = 'Colusa' AND MailState = 'CA') /         (SELECT COUNT(*) FROM schools WHERE County = 'Humboldt' AND MailState = 'CA');
SELECT COUNT(*) AS active_schools_count FROM schools WHERE mail_state = 'CA'   AND city = 'San Francisco'   AND closed_date IS NULL; 
  SELECT Phone, Ext FROM schools s WHERE s.CDSCode = (     SELECT cds      FROM satscores      WHERE AvgScrWrite IS NOT NULL      ORDER BY AvgScrWrite DESC      LIMIT 1 OFFSET 332 );
  SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';
  SELECT Website FROM schools WHERE (AdmFName1 = 'Mike' AND AdmLName1 = 'Larson') OR (AdmFName1 = 'Dante' AND AdmLName1 = 'Alvarez');
  SELECT DISTINCT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1;
  SELECT COUNT(*) FROM schools WHERE Charter = 1 AND City = 'Hickman' AND DOC = 52;
SELECT COUNT(schools.School)  FROM schools  JOIN frpm ON schools.CDSCode = frpm.CDSCode  WHERE schools.County = 'Los Angeles'  AND schools.Charter = 0  AND (frpm.`Free Meal Count (K-12)` / frpm.`Enrollment (K-12)`) * 100 < 0.18; 
  SELECT School, City, AdmFName1, AdmLName1 FROM schools WHERE Charter = 1 AND CharterNum = '00D2';
  SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4';
SELECT      (COUNT(CASE WHEN FundingType = 'locally funded' THEN 1 END) / COUNT(*)) * 100 AS Percentage_Locally_Funded FROM      schools WHERE      County = 'Santa Clara'; 
SELECT COUNT(*) FROM schools WHERE FundingType = 'Directly Funded' AND County = 'Stanislaus' AND OpenDate BETWEEN '2000-01-01' AND '2005-12-31'; 
  SELECT COUNT(School) AS Total FROM schools WHERE City = 'San Francisco' AND ClosedDate LIKE '%1989%' AND DOCType = 'Community College District';
SELECT County, COUNT(*) AS ClosureCount FROM schools WHERE StatusType = 'Closed'   AND ClosedDate >= '1980-01-01'   AND ClosedDate <= '1989-12-31'   AND SOC = '11' GROUP BY County ORDER BY ClosureCount DESC LIMIT 1; 
SELECT DISTINCT `NCESDist` FROM `schools` WHERE `SOC` = '31'; 
  SELECT `StatusType`, COUNT(*) AS `Count` FROM `schools` WHERE `County` = 'Alpine' GROUP BY `StatusType`;
  SELECT `District Code` FROM `frpm`  JOIN `schools` ON `frpm`.`CDSCode` = `schools`.`CDSCode`  WHERE `City` = 'Fresno' AND `Magnet` = 0;
  SELECT SUM(`Enrollment  (Ages 5-17)`) AS Total_Enrollment FROM frpm f JOIN schools s ON f.CDSCode = s.CDSCode WHERE `Academic Year` = '2014-2015' AND s.EdOpsCode = 'SSS';
  SELECT `FRPM Count (Ages 5-17)` FROM `frpm` INNER JOIN `schools` ON `frpm`.`CDSCode` = `schools`.`CDSCode` WHERE `MailStreet` = 'PO Box 1040';
SELECT MIN(frpm."Low Grade") AS MinimumGrade  FROM frpm  INNER JOIN schools ON frpm.CDSCode = schools.CDSCode  WHERE schools.EdOpsCode = 'SPECON' AND schools.NCESDist = '0613360'; 
  SELECT s.EILName, s.School FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE f.`NSLP Provision Status` = 'Breakfast Provision 2' AND f.`County Code` = '37';
  SELECT `City` FROM `frpm`  INNER JOIN `schools` ON `frpm`.`CDSCode` = `schools`.`CDSCode`  WHERE `frpm`.`NSLP Provision Status` = 'Breakfast Provision 2'  AND `frpm`.`Low Grade` = '9'  AND `frpm`.`High Grade` = '12'  AND `schools`.`EILCode` = 'HS'  AND `schools`.`County` = 'Merced';
  SELECT s.School, (f.`FRPM Count  (Ages 5-17)` / f.`Enrollment  (Ages 5-17)` * 100) AS `Percent (%) Eligible FRPM (Ages 5-17)` FROM frpm f JOIN schools s ON f.CDSCode = s.CDSCode WHERE s.County = 'Los Angeles' AND s.GSserved = 'K-9';
SELECT `GSserved`, COUNT(*) AS Count  FROM `schools`  WHERE `City` = 'Adelanto'  GROUP BY `GSserved`  ORDER BY Count DESC  LIMIT 1; 
  SELECT County, COUNT(*) AS School_Count   FROM schools   WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F'   GROUP BY County   ORDER BY School_Count DESC;
  SELECT s.`CDSCode`, f.`School Name`, f.`School Type`, s.`Latitude` FROM `frpm` AS f JOIN `schools` AS s ON f.`CDSCode` = s.`CDSCode` WHERE s.`Latitude` = (     SELECT MAX(`Latitude`)     FROM `schools` ) ORDER BY s.`Latitude` DESC;
SELECT      s.City,     f.`School Name`,     f.`Low Grade` FROM      schools s JOIN      frpm f ON s.CDSCode = f.CDSCode WHERE      s.State = 'CA' AND s.Latitude = (         SELECT MIN(s2.Latitude)          FROM schools s2          WHERE s2.State = 'CA'     ); 
SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1; 
python import pandas as pd from scipy.stats import chi2_contingency  # Assuming 'df' is your DataFrame containing the necessary columns  # Step 1: Filter magnet K-8 schools magnet_k8 = df[(df['is_magnet'] == 1) & (df['grade_span'].str.contains('K-8'))]  # Count number of magnet K-8 schools with multiple provisions magnet_multiple = len(magnet_k8[magnet_k8['nslp_provision_type'].apply(lambda x: len(x.split(',')) > 1)])  total_magnet = len(magnet_k8) prop_magnet = magnet_multiple / total_magnet  # Step 2: Filter non-magnet K-8 schools non_magnet_k8 = df[(df['is_magnet'] == 0) & (df['grade_span'].str.contains('K-8'))]  non_magnet_multiple = len(non_magnet_k8[non_magnet_k8['nslp_provision_type'].apply(lambda x: len(x.split(',')) > 1)]) total_non_magnet = len(non_magnet_k8) prop_non_magnet = non_magnet_multiple / total_non_magnet  # Step 3: Create contingency table observed = [[magnet_multiple, total_magnet - magnet_multiple],            [non_magnet_multiple, total_non_magnet - non_magnet_multiple]]  chi2_stat, p_val, dof, expected = chi2_contingency(observed)  print(f"Chi-squared statistic: {chi2_stat}") print(f"P-value: {p_val}")  if p_val < 0.05:     print("There is a statistically significant difference.") else:     print("No significant difference found.") 
SELECT District, COUNT(AdmFName1) AS Count  FROM schools  WHERE District IS NOT NULL  GROUP BY AdmFName1  ORDER BY Count DESC  LIMIT 2; 
  SELECT      frpm.`District Code`,      (frpm.`Free Meal Count  (K-12)` / frpm.`Enrollment  (K-12)` * 100) AS `PercentEligibleFree` FROM      frpm JOIN      schools ON frpm.CDSCode = schools.CDSCode WHERE      schools.AdmFName1 = 'Alusine';
  SELECT County, District, School, AdmLName1 FROM schools WHERE CharterNum = '40';
SELECT COALESCE(AdmEmail1, AdmEmail2, AdmEmail3) AS EmailAddress  FROM schools  WHERE County = 'San Bernardino'      AND District = 'City of San Bernardino City Unified'      AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'      AND (SOC = 62 OR DOC = 54)      AND AdmEmail1 IS NOT NULL; 
  SELECT s.School, ss.AdmEmail1 FROM schools s JOIN satscores sc ON s.CDSCode = sc.cds WHERE sc.NumGE1500 IS NOT NULL ORDER BY sc.NumGE1500 DESC LIMIT 1;
SELECT COUNT(*) FROM account  JOIN district ON account.district_id = district.district_id  WHERE account.frequency = 'POPLATEK PO OBRATU' AND district.A3 = 'East Bohemia'; 
SELECT COUNT(*) FROM account  JOIN district ON account.district_id = district.district_id  WHERE district.A3 = 'Prague'  AND EXISTS (SELECT * FROM loan WHERE loan.account_aid = account.account_aid); 
  SELECT AVG(A12) AS avg_1995, AVG(A13) AS avg_1996 FROM district;
  To determine how many districts have a female average between 6001 and 9999, we assume that each district's A11 value represents the average salary of its female clients. Based on the sample data provided:  - Districts B and C have A11 values within the specified range (7800 and 9200 respectively).    Therefore, the number of districts meeting this criterion is:  **2**  \boxed{2}
  SELECT COUNT(client.client_id) AS count FROM client JOIN district ON client.district_id = district.district_id WHERE gender = 'M' AND A3 = 'North Bohemia' AND A11 > 8000;
WITH min_birth AS (     SELECT MIN(birth_date) AS min_bd     FROM client     WHERE gender = 'F' ), oldest_districts AS (     SELECT c.district_id     FROM client c     WHERE c.gender = 'F' AND c.birth_date = (SELECT min_bd FROM min_birth) ), min_a11_dist AS (     SELECT district_id, A11     FROM account a     WHERE a.A11 = (SELECT MIN(A11) FROM account) ), final_dists AS (     SELECT od.district_id     FROM oldest_districts od     JOIN min_a11_dist mad ON od.district_id = mad.district_id ) SELECT a.account_number FROM account a WHERE a.district_id IN (SELECT district_id FROM final_dists); 
 WITH MaxSalary AS (     SELECT MAX(A11) AS max_avg_salary     FROM district ),  HighSalaryDistricts AS (     SELECT d.district_id, d.A11     FROM district d     WHERE d.A11 = (SELECT max_avg_salary FROM MaxSalary) ),  YoungestInDistricts AS (     SELECT c.birth_ate     FROM client c     WHERE c.district_id IN (SELECT hd.district_id FROM HighSalaryDistricts hd)     ORDER BY c.birth_ate DESC     LIMIT 1 )  SELECT c.* FROM client c WHERE c.district_id IN (SELECT hd.district_id FROM HighSalaryDistricts hd) AND c.birth_ate = (SELECT yid.birth_ate FROM YoungestInDistricts yid); 
SELECT COUNT(DISTINCT a.account_id)  FROM account a  JOIN disp d ON a.account_id = d.account_id  WHERE a.frequency = 'POPLATEK TYDNE' AND d.type = 'OWNER'; 
SELECT DISTINCT c.client_id FROM account a JOIN trans t ON a.account_id = t.account_id WHERE t.k_symbol = 'POPLATEK PO OBRATU'; 
  SELECT a.account_id FROM account a  INNER JOIN loan l ON a.account_id = l.account_id WHERE YEAR(l.date) = 1997  AND a.frequency = 'POPLATEK TYDNE' GROUP BY a.account_id HAVING l.amount = (     SELECT MIN(amount)     FROM loan     WHERE YEAR(date) = 1997 );
SELECT      d.account_id,     MAX(l.amount) AS max_approved_amount FROM      disp d JOIN      loan l ON d.account_aid = l.account_aid WHERE      l.duration > 12 GROUP BY      d.account_aid ORDER BY      max_approved_amount DESC LIMIT 1; 
SELECT COUNT(c.client_id) AS female_customers_count FROM client c JOIN account a ON c.client_id = a.client_id JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'F' AND YEAR(c.birth_date) < 1950 AND d.A2 = 'Sokolov'; 
SELECT account_id FROM trans WHERE date = (SELECT MIN(date) FROM trans); 
  SELECT a.account_id  FROM account a  JOIN trans t ON a.account_id = t.account_id  WHERE a.date < '1997-01-01'  GROUP BY a.account_id  HAVING SUM(t.amount) > 3000;
  SELECT c.client_id FROM client c JOIN disp d ON c.client_id = d.client_id JOIN card crd ON d.disp_id = crd.disp_id WHERE crd.issued = '1994-03-03';  Note: Based on the provided data, there is no record with issuance date '1994-03-03' in the `card` table. The earliest issuance date present is '1995-04-24'.
SELECT `account`.`date`  FROM `trans`  JOIN `account` ON `trans`.`account_id` = `account`.`account_id`  WHERE `trans`.`date` = '1998-10-14' AND `trans`.`amount` = 840; 
  SELECT `account`.`district_id`  FROM `loan`  JOIN `account` ON `loan`.`account_id` = `account`.`account_id`  WHERE `loan`.`date` = '1994-08-25';
  SELECT MAX(amount) FROM trans WHERE account_id IN (SELECT account_id FROM account WHERE date = '1996-10-21');
  SELECT (SELECT `gender` FROM `client` WHERE `birth_date` = (SELECT MIN(`birth_ate`) FROM `client` c JOIN `district` d ON c.`district_id` = d.`district_id` WHERE d.A11 = (SELECT MAX(A11) FROM `district`)))) AS gender;
WITH MaxLoan AS (     SELECT          account_id,         MAX(amount) as max_loan_amount     FROM          loan     GROUP BY          account_id ), MaxAccount AS (     SELECT          ml.account_id     FROM          MaxLoan ml     WHERE          ml.max_loan_amount = (SELECT MAX(amount) FROM loan) ) SELECT      t.amount FROM      trans t JOIN      MaxAccount ma ON t.account_id = ma.account_id ORDER BY      t.date ASC LIMIT 1; 
SELECT COUNT(*) FROM client c JOIN district d ON c.district_id = d.district_id WHERE d.A2 = 'Jesenik' AND c.gender = 'F'; 
SELECT disp.disp_id FROM trans  JOIN disp ON trans.account_id = disp.account_id  WHERE trans.amount = 5100 AND trans.date = '1998-09-02'; 
SELECT COUNT(*) FROM account  JOIN district ON account.district_id = district.district_id  WHERE district.A2 = 'Litomerice' AND YEAR(account.date) = 1996; 
SELECT * FROM client WHERE birth_ate BETWEEN '2000-01-01' AND '2015-12-31'; 
SELECT c.birth_date FROM loan l JOIN account a ON l.account_id = a.account_id JOIN client c ON a.district_id = c.district_id WHERE l.amount = 98832 AND l.date = '1996-01-03'; 
SELECT a.account_id  FROM account a  JOIN district d ON a.district_id = d.district_id  WHERE d.A3 = 'Prague'  ORDER BY a.date ASC  LIMIT 1; 
SELECT      (COUNT(CASE WHEN c.gender = 'M' THEN 1 END) / COUNT(*)) * 100 AS percentage_of_males FROM      client c JOIN      district d ON c.district_id = d.district_id WHERE      d.A3 = 'south Bohemia' GROUP BY      d.district_id ORDER BY      CAST(d.A4 AS UNSIGNED) DESC LIMIT 1; 
DELIMITER $$ CREATE FUNCTION CalculateGrowthRate(     startDate DATE,     endDate DATE ) RETURNS DECIMAL(10,2) DETERMINISTIC BEGIN     DECLARE accountId INT;     DECLARE totalCredits DECIMAL(15,2);     DECLARE totalDebits DECIMAL(15,2);     DECLARE initialBalance DECIMAL(15,2);     DECLARE finalBalance DECIMAL(15,2);     DECLARE growthRate DECIMAL(10,2);           SELECT account_id      INTO accountId      FROM loan      WHERE loan_date >= '1993-07-05'     ORDER BY loan_date ASC      LIMIT 1;           SELECT COALESCE(SUM(credit), 0) AS totalCredits, COALESCE(SUM(debit), 0) AS totalDebits     INTO totalCredits, totalDebits     FROM trans      WHERE account_id = accountId AND trans_date BETWEEN startDate AND endDate;                     SET initialBalance = 0;           SET finalBalance = initialBalance + totalCredits - totalDebits;           IF finalBalance = initialBalance THEN         SET growthRate = 0.0;     ELSEIF initialBalance = 0 AND finalBalance > 0 THEN         SET growthRate = 100.0;      ELSE         SET growthRate = ((finalBalance - initialBalance) / initialBalance) * 100;     END IF;      RETURN growthRate; END$$  DELIMITER ; 
  SELECT      (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage,     SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS sum_A,     SUM(amount) AS total_sum FROM loan
  SELECT      (SUM(CASE WHEN amount < 100000 AND status = 'C' THEN amount ELSE 0 END) /       SUM(CASE WHEN amount < 100000 THEN amount ELSE 0 END)) * 100 AS percentage FROM loan;    
SELECT a.account_id, d.A2 AS district_name, d.A3 AS district_region  FROM account a  JOIN district d ON a.district_id = d.district_id  WHERE YEAR(a.date) = 1993 AND a.frequency = 'POPLATEK PO OBRATU'; 
SELECT a.account_id, a.frequency  FROM account AS a  JOIN district AS d ON a.district_id = d.district_id  WHERE d.A3 = 'east Bohemia' AND a.date BETWEEN '1995-01-01' AND '2000-12-31'; 
  SELECT a.account_id, a.date FROM account a JOIN district d ON a.district_id = d.district_id WHERE d.A2 = 'Prachatice';
  SELECT `A2`, `A3`  FROM `district`  JOIN `account` ON `district`.`district_id` = `account`.`district_id`  JOIN `loan` ON `account`.`account_id` = `loan`.`account_id`  WHERE `loan`.`loan_id` = 4990;
SELECT loan.account_aid AS account_id, district.A2 AS district, district.A3 AS region  FROM loan  INNER JOIN account ON loan.account_aid = account.account_aid  INNER JOIN district ON account.district_id = district.district_id  WHERE loan.amount > 300000; 
  SELECT loan.loan_id, district.A2 AS district, district.A11 AS average_salary FROM loan JOIN account ON loan.account_aid = account.account_id JOIN district ON account.district_id = district.district_id WHERE loan.duration = 60;
  SELECT      d.district_id,     ((d.A13 - d.A12) / d.A12) * 100 AS unemployment_rate_increment FROM      loan l JOIN      account a ON l.account_aid = a.account_id JOIN      district d ON a.district_id = d.district_id WHERE      l.status = 'D';
SELECT      (SUM(CASE WHEN d.A2 = 'Decin' THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) * 100 AS percentage FROM      account a  JOIN      district d ON a.district_id = d.district_id WHERE      YEAR(a.date) = 1993; 
SELECT a.account_id FROM account a JOIN statement_issuance si ON a.account_id = si.account_id WHERE si.issuance_type = 'POPLATEK MESICNE'; 
SELECT     t.bank AS district_code,     COUNT(DISTINCT a.account_id) AS female_account_count FROM     client c JOIN     account_client ac ON c.client_id = ac.client_id JOIN     account a ON ac.account_id = a.account_id JOIN     trans t ON a.account_id = t.account_id WHERE     c.gender = 'F' GROUP BY     t.bank ORDER BY     female_account_count DESC LIMIT 9; 
  The SQL query cannot be constructed as per the request because the 'trans' table does not contain an amount field necessary to determine the size of withdrawals. Without this information, it's impossible to identify the top ten withdrawals by district. Please review the schema and data for any missing fields or clarify how withdrawal amounts are recorded.
SELECT COUNT(*)  FROM (     SELECT c.client_id     FROM client c     JOIN district d ON c.district_id = d.district_id      WHERE d.A3 = 'South Bohemia' ) AS south_clients WHERE EXISTS (     SELECT 1      FROM disp      WHERE client_id = south_clients.client_id AND type = 'OWNER' ) AND NOT EXISTS (     SELECT 1      FROM disp      WHERE client_id = south_clients.client_id AND type = 'DISPONENT' ); 
SELECT d.A3 AS District, SUM(l.amount) AS TotalActiveLoan  FROM loan l  JOIN account a ON l.account_id = a.account_id  JOIN district d ON a.district_id = d.district_id  WHERE l.status IN ('C', 'D')  GROUP BY d.A3  ORDER BY TotalActiveLoan DESC  LIMIT 1; 
python import sqlite3  # Establish connection to the database (assuming the data is in a SQLite DB) conn = sqlite3.connect('bank.db') cursor = conn.cursor()  # Step 1: Find all districts with male clients query_dists_with_males = """ SELECT DISTINCT district_id  FROM client  WHERE gender = 'M'; """ cursor.execute(query_dists_with_males) male_districts = [row[0] for row in cursor.fetchall()]  # Step 2 and 3: Sum the loans and count them in these districts total_loan_sum = 0 loan_count = 0  for dist_id in male_districts:     # Get all accounts in this district     query_accounts_in_dist = """     SELECT account_id      FROM account      WHERE district_id = ?;     """     cursor.execute(query_accounts_in_dist, (dist_id,))     accounts = [row[0] for row in cursor.fetchall()]          # For each account, get the loan amount(s)     for acc_id in accounts:         query_loans_for_account = """         SELECT amount          FROM loan          WHERE account_id = ?;         """         cursor.execute(query_loans_for_account, (acc_id,))         loans = [row[0] for row in cursor.fetchall()]                  total_loan_sum += sum(loans)         loan_count += len(loans)  # Step 4: Calculate average if loan_count == 0:     average_loan = 0 else:     average_loan = total_loan_sum / loan_count  print(f"The average loan amount from districts with male borrowers is: {average_loan:.2f}") 
  SELECT A2 AS DistrictName, A13 AS UnemploymentRate FROM district ORDER BY A13 DESC;
  SELECT COUNT(account_id) FROM account WHERE district_id = (SELECT district_id FROM district ORDER BY A16 DESC LIMIT 1);
  SELECT COUNT(DISTINCT a.account_id) FROM trans t JOIN account a ON t.account_id = a.account_id WHERE t.operation = 'VYBER KARTOU' AND t.balance < 0 AND a.frequency = 'POPLATEK MESICNE';
  SELECT COUNT(*) FROM account a JOIN loan l ON a.account_id = l.account_id WHERE l.date >= '1995-01-01' AND l.date <= '1997-12-31' AND l.amount >= 250000 AND a.frequency = 'POPLATEK MESICNE';
SELECT COUNT DISTINCT(a.account_id)  FROM account a  JOIN loan l ON a.account_id = l.account_id  WHERE a.district_id = 1 AND (l.status = 'C' OR l.status = 'D'); 
<think> Okay, so I need to figure out how to write an SQL query based on the user's question. Let me start by breaking down what they're asking.  The question is: "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?"   First, I'll note that A15 represents the number of crimes committed in 1995. The district table has this column, and each district corresponds to a branch.  So, step one is to find the district with the second-highest A15 value. To do that, I can order the districts by A15 in descending order and pick the second one. But wait, if there are multiple districts with the same A15 value, does the second-highest refer to the next distinct value or just the second row? The question says "second-highest," so it's likely referring to the second highest unique value.  Next, once I have that district ID, I need to find out how many male clients are in that district. Looking at the client table, gender 'M' represents males. The client_id is the primary key, but we can count the entries where district_id matches our target district and gender is 'M'.  But wait, looking at the provided data, the INSERT INTO statements for the client table have values like (1, 18, 'F'), which suggests that the columns are client_id, age, and gender. Wait, but in the schema, client has client_id, gender, district_id. So, there's a discrepancy hereâ€”probably a typo in the data provided because the third value is a string ('F' or 'M') for gender, and the second column should be an integer (district_id). But in the INSERT statements, it's written as (1, 18, 'F'), which would imply that district_id is 18. That seems odd because looking at the district table, district_ids are between 1 and 5. So perhaps the data provided has a mistake. Alternatively, maybe the age was mistakenly included instead of district_id.  Wait, no, in the CREATE TABLE for client, the columns are client_id (INTEGER), gender (TEXT), and district_id (INTEGER). But in the INSERT statements, it's given as (1, 18, 'F'), which would be client_id=1, gender=18 (but that doesn't make sense because gender is a TEXT field), so perhaps there's an error. Alternatively, maybe the age was mistakenly included instead of district_id. But since the user provided this data, I'll proceed with what's given.  So, assuming the data is correct, even though it seems odd, we have clients with district_ids like 18 and 5, but in the district table, the IDs are from 1 to 5. So, perhaps there's a mistake, but for the purpose of this query, I'll proceed as if the client entries are correct.  But wait, looking at the client data:  INSERT INTO `client` VALUES (1, 18, 'F'); (2, 1, 'M'); (3, 1, 'F'); (4, 5, 'M'); (5, 5, 'F');  So, client_id=1 has district_id=18? But in the district table, district_ids are only up to 5. So perhaps that's a mistake, but I'll proceed.  But for the purpose of this query, it might not matter because we're focusing on the districts where A15 is the second-highest, which would have a district_id between 1 and 5 as per the data.  So, first step: find the district with the second-highest A15 value.  To do that, I can select A15 from the district table and order them in descending order. Then, pick the second one. But since there might be duplicates, it's better to get distinct values.  Wait, but let me check the A15 values:  district_id | A15 1 | 85677 2 | 2159 3 | 2824 4 | 5244 5 | 2616  So, sorted in descending order: 85677 (district 1), then 5244 (district 4), followed by 2824 (district 3), then 2616 (district 5), and lastly 2159 (district 2). So, the second-highest is 5244 in district 4.  So, now I need to find how many male clients are in district 4. In the client table, count where district_id=4 and gender='M'.  Looking at the client data:  client_id | age | gender 1 | 18 | F 2 | 1 | M 3 | 1 | F 4 | 5 | M 5 | 5 | F  Wait, but according to the schema, district_id is an integer not null. So in the client table, the third column should be district_id, but in the INSERT statements, it's 'F' or 'M', which are strings. That can't be right because district_id is an INTEGER. So perhaps there's a mistake in the data provided.  Wait, let me recheck:  The user provided:  INSERT INTO `client` VALUES (1, 18, 'F'); (2, 1, 'M'); (3, 1, 'F'); (4, 5, 'M'); (5, 5, 'F');  But the schema is:  CREATE TABLE `client`  (     `client_
SELECT COUNT(*)  FROM card  JOIN disposition ON card.account_id = disposition.account_id  WHERE card.type = 'gold' AND disposition.type = ' OWNER'; 
  SELECT COUNT(*) FROM account a JOIN district d ON a.district_id = d.district_id WHERE d.A2 = 'Pisek';
SELECT a.district_id, SUM(t.amount) AS total_transactions FROM transaction t JOIN account a ON t.account_aid = a.account_id WHERE YEAR(t.date) = 1997 GROUP BY a.district_id HAVING total_transactions > 10000; 
  SELECT a.account_id FROM account a JOIN trans t ON a.account_id = t.account_aid JOIN district d ON a.district_aid = d.district_id WHERE d.district_id = 2 AND t.k_symbol = 'SIPO';
SELECT DISTINCT a.account_id  FROM account a  JOIN card c ON a.account_id = c.account_id  WHERE c.type = 'gold'; 
  SELECT      YEAR(t.date) AS year,     MONTH(t.date) AS month,     AVG(t.amount) AS average_amount FROM trans t JOIN disp d ON t.account_id = d.account_id JOIN card c ON d.disp_id = c.disp_id WHERE t.operation = 'VYBER KARTOU' AND YEAR(t.date) = 2021 GROUP BY year, month;
SELECT DISTINCT trans.account_id  FROM trans  WHERE trans.operation = 'VYBER KARTOU'    AND trans.date BETWEEN '1998-01-01' AND '1998-12-31'    AND trans.amount < (     SELECT AVG(amount)      FROM trans      WHERE operation = 'VYBER KARTOU'        AND date BETWEEN '1998-01-01' AND '1998-12-31'   ); 
  SELECT c.client_id FROM client AS c JOIN disp AS dp ON c.client_ = dp.client_ JOIN card AS cr ON dp.disp_ = cr.disp_ WHERE c.gender = 'F' AND dp.account_ IN (SELECT account_ FROM loan);
SELECT COUNT(*) AS female_clients_in_south_bohemia FROM client JOIN district ON client.district_id = district.id WHERE client.gender = 'F' AND district.A3 = 'South Bohemia'; 
  SELECT `a`.`account_id` FROM `account` AS `a` INNER JOIN `district` AS `d` ON `a`.`district_id` = `d`.`district_id` INNER JOIN `disp` AS `dp` ON `a`.`account_id` = `dp`.`account_ id` WHERE `d`.`A2` = 'Tabor' AND `dp`.`type` = 'OWNER';
  SELECT `type` FROM `disp`  JOIN `account` ON `disp`.`account_id` = `account`.`account_id`  JOIN `district` ON `account`.`district_id` = `district`.`district_id`  WHERE `district`.`A11` > 8000 AND `district`.`A11` <= 9000 AND `type` != 'OWNER'  GROUP BY `type`;
SELECT COUNT(DISTINCT t.account_id)  FROM account a  JOIN district d ON a.district_id = d.district_id  JOIN trans t ON a.account_id = t.account_id  WHERE d.A3 = 'North Bohemia' AND t.bank = 'AB'; 
SELECT d.A2  FROM district d  JOIN account a ON d.district_id = a.district_id  JOIN trans t ON a.account_aid = t.account_aid  WHERE t.type = 'VYDAJ' AND t.account_aid IS NOT NULL; 
SELECT AVG(d.A15) as avg_crimes FROM district d JOIN account a ON d.district_id = a.district_id WHERE d.A15 > 4000 AND a.date >= '1997-01-01' GROUP BY d.district_id; 
SELECT COUNT(*)  FROM card  INNER JOIN disp ON card.disp_id = disp.disp_id  WHERE card.type = 'classic' AND disp.type = 'OWNER'; 
SELECT COUNT(*)  FROM client c  INNER JOIN district d ON c.district_id = d.district_id  WHERE c.gender = 'M' AND d.A2 = 'Hl. m. Praha'; 
  SELECT      (SELECT COUNT(*) FROM card WHERE type = 'gold' AND issued < '1998-01-01') / (SELECT COUNT(*) FROM card) * 100 AS percentage;
SELECT d.client_id FROM disp d WHERE d.account_id IN (     SELECT l.account_id     FROM loan l     WHERE l.amount = (SELECT MAX(amount) FROM loan) ) AND d.type = 'OWNER'; 
  SELECT `district`.`A15` FROM `account` INNER JOIN `district` ON `account`.`district_id` = `district`.`district_id` WHERE `account`.`account_id` = 532;
SELECT district.district_id FROM district  JOIN account ON district.district_id = account.district_id  JOIN `order` ON account.account_id = `order`.account_id  WHERE `order`.order_id = 33333; 
  SELECT trn.trans_id, trn.account FROM trans trn JOIN disp dsp ON trn.account_id = dsp.account_id JOIN client clt ON dsp.client_id = clt.client_id WHERE clt.client_id = 3356 AND trn.operation = 'VYBER';
SELECT COUNT(*)  FROM account a  JOIN loan l ON a.account_id = l.account_id  WHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000; 
  SELECT c.type   FROM card c   JOIN disp d ON c.disp_id = d.disp_id   JOIN client cl ON d.client_id = cl.client_id   WHERE cl.client_id = 13539;
  To determine the region of the client with ID 3541, we need to retrieve the corresponding district information from the database. The SQL query joins the 'client' and 'district' tables based on their 'district_id' and fetches the 'A3' column, which represents the region.  SELECT `A3` FROM `district` WHERE `district_id` = (SELECT `district_id` FROM `client` WHERE `client_id` = 3541);
SELECT a.district_id  FROM account AS a  INNER JOIN loan AS l ON a.account_id = l.account_id  WHERE l.status = 'A'  GROUP BY a.district_id  ORDER BY COUNT(*) DESC  LIMIT 1; 
  SELECT c.client_id FROM `order` AS o JOIN `account` AS a ON o.account_id = a.account_1d JOIN `client` AS c ON a.district_id = c.district_id WHERE o.order_id = 32423;  However, upon closer inspection and considering the database schema provided:  The SQL query should be:  SELECT c.client_id FROM `order` AS o  JOIN `account` AS a ON o.account_id = a.account_1d  JOIN `client` AS c ON a.district_id = c.district_id  WHERE o.order_id = 32423;  But there is no order with ID 32423 in the provided database. Therefore, this query will return an empty result.  Given the structure of your database and the data provided, you might need to adjust the tables or add more data if you want to retrieve a specific client for a given order.  The correct SQL query based on the schema is:
SELECT t.trans_id, t.account_id FROM trans t  JOIN account a ON t.account_id = a.account_id  WHERE a.district_id = 5; 
  SELECT COUNT(*) FROM account JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Jesenik';
SELECT d.client_id  FROM disp d  JOIN card c ON d.disp_id = c.disp_aid  WHERE c.type = 'junior' AND c.issued >= '1997-01-01'; 
  SELECT      (COUNT(CASE WHEN c.gender = 'F' THEN c.client_id END) / COUNT(DISTINCT c.client_id)) * 100 AS percentage_women FROM      client c JOIN      district d ON c.district_id = d.district_id WHERE      d.A11 > 10000;
SELECT      SUM(CASE WHEN YEAR(l.date) = 1996 THEN l.amount ELSE 0 END) AS total_1996,     SUM(CASE WHEN YEAR(l.date) = 1997 THEN l.amount ELSE 0 END) AS total_1997,     ((SUM(CASE WHEN YEAR(l.date) = 1997 THEN l.amount ELSE 0 END) -        SUM(CASE WHEN YEAR(l.date) = 1996 THEN l.amount ELSE 0 END)) /       SUM(CASE WHEN YEAR(l.date) = 1996 THEN l.amount ELSE 0 END)) * 100 AS growth_rate FROM      loan l JOIN      disp d ON l.account_aid = d.account_aid JOIN      client c ON d.client_id = c.client_id WHERE      c.gender = 'M' AND YEAR(l.date) IN (1996, 1997); 
SELECT COUNT(*) FROM trans WHERE operation = 'VYBER KARTOU' AND date >= '1995-01-01'; 
  SELECT (SELECT SUM(A16) FROM district WHERE A3 = 'North Bohemia') - (SELECT SUM(A16) FROM district WHERE A3 = 'East Bohemia');
  SELECT `type`, COUNT(`account_id`) FROM `disp` WHERE `account_id` BETWEEN 1 AND 10 GROUP BY `type`;
SELECT frequency FROM account WHERE account_id = 3; SELECT amount, k_symbol FROM order WHERE account_id = 3; 
SELECT YEAR(birth_date) AS birth_year  FROM client  JOIN disp ON client.client_id = disp.client_id  WHERE disp.account_id = 130; 
  SELECT COUNT(*) FROM `account` a JOIN `disp` d ON a.`account_id` = d.`account_id` WHERE d.`type` = 'OWNER' AND a.`frequency` = 'POPLATEK PO OBRATU';
SELECT      SUM(l.amount) AS total_debt,     CASE          WHEN COUNT(CASE WHEN l.status = 'A' THEN 1 END) > 0 THEN 'Active Loans'         WHEN COUNT(CASE WHEN l.status = 'B' THEN 1 END) > 0 THEN 'Past Due Loans'         ELSE 'No Active or Past Due Loans'     END AS payment_status FROM      client c JOIN      account a ON c.district_id = a.district_id JOIN      loan l ON a.account_id = l.account_id WHERE      c.client_id = 992; 
WITH TransactionBalances AS (     SELECT          t.account_id,         c.client_id,         c.gender,         t.amount,         ROW_NUMBER() OVER (PARTITION BY t.account_id ORDER BY t.date) AS trans_order     FROM          transaction t     JOIN          account a ON t.account_id = a.account_id     JOIN          client c ON a.client_id = c.client_id ) SELECT      tb.account_id,     tb.client_id,     tb.gender,     tb.trans_order,     SUM(tb.amount) OVER (PARTITION BY tb.account_id ORDER BY tb.trans_order ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_balance FROM      TransactionBalances tb; 
  SELECT c.type FROM card c  	INNER JOIN disp d ON c.disp_id = d.disp_ion  	INNER JOIN client cl ON d.client_id = cl.client_ion  	WHERE cl.client_ion = 9;
SELECT SUM(t.amount) AS total_amount_paid FROM trans t JOIN account a ON t.account_id = a.account_id WHERE a.district_id IN (     SELECT district_id      FROM client      WHERE client_id = 617 ) AND YEAR(t.date) = 2019; 
SELECT c.client_id FROM Client c JOIN Account a ON c.client_id = a.client_id JOIN District d ON a.branchDistrict_id = d.district_id WHERE c.birth_date BETWEEN '1983-01-01' AND '1987-12-31' AND d.A3 = 'East Bohemia'; 
SELECT c.client_id, SUM(l.loan_amount) AS total_loan FROM client c JOIN account a ON c.district_id = a.district_id JOIN loan l ON a.account_id = l.account_id WHERE c.gender = 'F' GROUP BY c.client_id ORDER BY total_loan DESC LIMIT 3; 
SELECT COUNT(*)  FROM client c  WHERE c.gender = 'M'  AND c.birth_date BETWEEN '1974-01-01' AND '1976-12-31'  AND EXISTS (     SELECT 1      FROM account a      JOIN trans t ON a.account_id = t.account_id      WHERE a.district_id = c.district_id      AND t.k_symbol = 'SIPO'      AND t.amount > 4000 ); 
  SELECT COUNT(*) FROM account a JOIN district d ON a.district_id = d.district_id WHERE d.A2 = 'Beroun' AND a.date > '1996-01-01';
  SELECT COUNT(*) FROM client  JOIN disp ON client.client_id = disp.client_id  JOIN card ON disp.disp_id = card.disp_id  WHERE client.gender = 'F' AND card.type = 'junior';
SELECT      (COUNT(CASE WHEN c.gender = 'F' THEN 1 END) / COUNT(c.client_id)) * 100 AS percentage_female FROM      client c JOIN      district d ON c.district_id = d.district_id WHERE      d.A3 = 'Prague'; 
SELECT      (COUNT(CASE WHEN gender = 'M' THEN 1 END) * 100.0 / COUNT(*)) AS male_weekly_percentage FROM client c JOIN account a ON c.district_id = a.district_id WHERE a.frequency = 'POPLATEK TYDNE'; 
SELECT COUNT(DISTINCT account_id) AS owner_count FROM trans WHERE type = 'POPLATEK TYDNE' AND operation IS NOT NULL; 
SELECT a.account_id  FROM account a  JOIN loan l ON a.account_id = l.account_id  WHERE l.duration > 24 AND a.date < '1997-01-01'  GROUP BY a.account_id  HAVING MIN(l.amount)  ORDER BY MIN(l.amount) ASC  LIMIT 1; 
WITH fc AS (     SELECT a.account_id, c.birth_date, d.A11     FROM account a     JOIN district d ON a.district_id = d.district_id     JOIN client c ON c.district_id = d.district_id     WHERE c.gender = 'F' ), max_birth_date AS (     SELECT MAX(birth_date) as max_bd     FROM fc ), min_A11 AS (     SELECT MIN(A11) as min_a11     FROM fc     WHERE birth_date = (SELECT max_bd FROM max_birth_date) ) SELECT account_id FROM fc WHERE birth_date = (SELECT max_bd FROM max_birth_date) AND A11 = (SELECT min_a11 FROM min_A11); 
  SELECT COUNT(*)  FROM client c  JOIN district d ON c.district_id = d.district_id  WHERE YEAR(c.birth_date) = 1920 AND d.A3 = 'east bohemia';
SELECT COUNT(*)  FROM loan l  INNER JOIN account a ON l.account_id = a.account_id  WHERE l.duration = 24 AND a.frequency = 'POPLATEK TYDNE'; 
  SELECT AVG(payments)  FROM loan  JOIN account ON loan.account_id = account.account_id  WHERE account.frequency = 'POPLATEK PO OBRATU'  AND (loan.status = 'C' OR loan.status = 'D');
SELECT d.client_id AS client_id, dist.A2 AS district  FROM disp d  JOIN account a ON d.account_id = a.account_id  JOIN district dist ON a.district_id = dist.district_id  WHERE d.type = 'OWNER'  AND NOT EXISTS (     SELECT 1      FROM disp d2      WHERE d2.client_id = d.client_id      AND d2.type = 'DISPONENT' ) GROUP BY d.client_id, dist.A2; 
SELECT c.client_id, (DATEDIFF(CURDATE(), c.birth_date) / 365) AS age  FROM client c  JOIN disp d ON c.client_id = d.client_id  WHERE d.type = 'OWNER' AND disp_ id IN (     SELECT disp_ id FROM card WHERE type = 'gold' ); 
SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(*) DESC LIMIT 1; 
SELECT COUNT(DISTINCT atom.molecule_id) FROM atom LEFT JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE element = 'cl' AND label = '-'; 
SELECT AVG(oxygen_count) AS average_oxygen  FROM (     SELECT COUNT(*) AS oxygen_count      FROM atom      WHERE element = 'o' AND molecule_id IN (         SELECT DISTINCT molecule_id          FROM bond          WHERE bond_type = '-'     )      GROUP BY molecule_id ); 
WITH selected_molecules AS (     SELECT molecule_id FROM molecule WHERE label = '+' ), bond_count AS (     SELECT COUNT(*) as total_bonds      FROM bond      WHERE molecule_id IN (SELECT molecule_id FROM selected_molecules) AND bond_type = '-' ), atom_count AS (     SELECT COUNT(*) as total_atoms      FROM atom      WHERE molecule_id IN (SELECT molecule_id FROM selected_molecules) ) SELECT      CAST(bond_count.total_bonds AS FLOAT) / atom_count.total_atoms FROM bond_count, atom_count; 
  SELECT COUNT(DISTINCT a.molecule_id) FROM atom AS a JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE a.element = 'na' AND m.label = '-';
SELECT m.molecule_id  FROM molecule m  WHERE m.label = '+'  AND EXISTS (     SELECT 1      FROM bond b      WHERE b.molecule_id = m.molecule_id      AND b.bond_type = '#' ); 
SELECT      (SUM(CASE WHEN element = 'c' THEN 1 ELSE 0 END) * 100.0 / COUNT(atom_id)) AS percentage FROM atom WHERE molecule_id IN (     SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '=' ); 
SELECT COUNT(*) FROM bond WHERE bond_type = '#'; 
  SELECT COUNT(*) FROM atom WHERE element != 'br';
SELECT COUNT(*) FROM molecule WHERE molecule_id BETWEEN 'TR000' AND 'TR099' AND label = '+'; 
SELECT DISTINCT molecule_id FROM atom WHERE element = 'c'; 
SELECT a.element  FROM connected c  JOIN atom a ON c.atom_id = a.atom_id  WHERE c.bond_id = 'TR004_8_9'; 
  SELECT DISTINCT element FROM atom JOIN bond ON atom.molecule_id = bond.molecule_id WHERE bond_type = '=';
SELECT molecule.label, COUNT(*) as cnt  FROM atom  JOIN molecule ON atom.molecule_id = molecule.molecule_0  WHERE element = 'h'  GROUP BY molecule.label  ORDER BY cnt DESC  LIMIT 1; 
SELECT DISTINCT b.bond_type FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE a.element = 'cl'; 
SELECT c.atom_id, c.atom_id2  FROM connected c  JOIN bond b ON c.bond_id = b.bond_id  WHERE b.bond_type = '-' AND c.atom_id < c.atom_id2  ORDER BY c.atom_id; 
  SELECT DISTINCT a(atom_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id JOIN connected c ON c.atom_id = a.atom_id WHERE m.label = '-';
SELECT a.element  FROM atom AS a  JOIN molecule AS m ON a.molecule_id = m.molecule_id  WHERE m.label = '-'  GROUP BY a.element  ORDER BY COUNT(a.element) ASC  LIMIT 1; 
  SELECT bond.bond_type  FROM connected  JOIN bond ON connected.bond_id = bond.bond_1d  WHERE (connected.atom_1d = 'TR004_8' AND connected.atom_2id = 'TR004_20')     OR (connected(atom_2id = 'TR004_8' AND connected.atom_1id = 'TR004_20')  ORDER BY bond.bond_type  LIMIT 1;
SELECT DISTINCT m.label FROM molecule m WHERE NOT EXISTS (     SELECT 1     FROM atom a     WHERE a.molecule_id = m.id AND a.element != 'sn' ); 
  SELECT COUNT(DISTINCT a.atom_id) AS count_single_bond_atoms FROM atom a JOIN connected c ON a.atom_id = c.atom_id  JOIN bond b ON c.bond_id = b.bond_id WHERE (a.element = 'i' OR a.element = 's') AND b.bond_type = '-';
  SELECT c(atom_id), c(atom_id2) FROM connected AS c  JOIN bond AS b ON c.bond_id = b.bond_id  WHERE b.bond_type = '#';
  SELECT atom_id2 FROM connected WHERE atom_id IN (SELECT atom_id FROM atom WHERE molecule_id = 'TR181') UNION SELECT atom_id FROM connected WHERE atom_id2 IN (SELECT atom_id FROM atom WHERE molecule_id = 'TR181');
SELECT      (         (SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m WHERE m.label = '+' AND NOT EXISTS (SELECT 1 FROM atom a WHERE m.molecule_id = a.molecule_id AND a.element = 'f'))         /         (SELECT COUNT(DISTINCT m2.molecule_id) FROM molecule m2 WHERE m2.label = '+')     ) * 100 AS percentage; 
  SELECT ROUND((SUM(bond_type = '#') * 100 / COUNT(*)) , 2) AS percent FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE m.label = '+';
SELECT element  FROM atom  WHERE molecule_id = 'TR000'  GROUP BY element  ORDER BY COUNT(element) DESC, element ASC  LIMIT 3; 
SELECT atom1, atom2 FROM atoms_in_bond WHERE bond_id = 'TR001_2_6'; 
SELECT SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END) AS difference FROM molecule; 
SELECT atom_id, atom_id2 FROM connected WHERE bond_id = 'TR000_2_5'; 
  SELECT `bond_id` FROM `connected` WHERE `atom_ id2` = 'TR000_2';
  SELECT `molecule_id` FROM `bond` WHERE `bond_ype` = '=' GROUP BY `molecule_id` ORDER BY COUNT(*) DESC, `molecule_id` ASC LIMIT 5;
  SELECT ROUND((SUM(CASE WHEN bond_type = '=' THEN 1 ELSE 0 END) * 100.0 / COUNT(bond_id)),5) AS percentage FROM bond WHERE molecule_id = 'TR008';
SELECT      ROUND((SUM(label = '+') / COUNT(molecule_id)) * 100, 3) AS percent  FROM molecule; 
  SELECT      (SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) / COUNT(atom_id)) * 100 AS percent FROM      atom WHERE      molecule_id = 'TR206';
  SELECT bond_type FROM bond WHERE molecule_id = '-';
  SELECT atom.element, molecule.label FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.molecule_id = 'TR060';
SELECT      (SELECT bond_type FROM bond WHERE molecule_id = 'TR010' GROUP BY bond_type ORDER BY COUNT(*) DESC LIMIT 1) AS majority_bond_type,     (SELECT label FROM molecule WHERE molecule_id = 'TR010') AS carcinogenic_status; 
  SELECT DISTINCT m.molecule_id FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE m.label = '-' AND b.bond_type = '-' ORDER BY m.molecule_id ASC LIMIT 3;
SELECT bond_id  FROM connected  WHERE atom_id IN (     SELECT atom_id      FROM atom      WHERE molecule_id = 'TR006' )  GROUP BY bond_id  ORDER BY bond_id ASC  LIMIT 2; 
SELECT COUNT(DISTINCT c.bond_id) AS num_bonds FROM connected c  JOIN bond b ON c.bond_id = b.bond_id  WHERE (c.atom_id = 'TR009_12' OR c.atom_id2 = 'TR009_12') AND b.molecule_id = 'TR009'; 
  SELECT COUNT(DISTINCT atom.molecule_id) FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.element = 'br' AND molecule.label = '+';
  SELECT bond_type FROM bond WHERE bond_id = 'TR001_6_9' LIMIT 1 UNION SELECT atom_1 AS atoms FROM connected WHERE bond_id = 'TR001_6_9' UNION SELECT atom_2 AS atoms FROM connected WHERE bond_id = 'TR001_6_9';
  SELECT m.molecule_id, m.label FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE a.atom_id = 'TR001_10';
SELECT COUNT(DISTINCT molecule_id) FROM bond WHERE bond_type = '#'; 
SELECT COUNT(*) FROM connected WHERE atom_id LIKE 'TR%_19'; 
  SELECT element FROM atom WHERE molecule_id = 'TR004';
SELECT COUNT(*) FROM molecule WHERE label = '-'; 
  SELECT DISTINCT m.molecule_id FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE SUBSTR(a.atom_id, 7, 2) BETWEEN '21' AND '25' AND m.label = '+';
SELECT BondID FROM Bonds WHERE (Atom1Symbol = 'N' AND Atom2Symbol = 'P')     OR (Atom1Symbol = 'P' AND Atom2Symbol = 'N'); 
  WITH bond_counts AS (     SELECT molecule_id, COUNT(*) AS double_bond_count     FROM bond     WHERE bond_type = '='     GROUP BY molecule_id ) SELECT m.label FROM (     SELECT molecule_id     FROM bond_counts     ORDER BY double_bond_count DESC     FETCH FIRST 1 ROW ONLY ) AS most_double_bonds JOIN molecule m ON most_double_bonds.molecule_id = m.molecule_id;
SELECT COALESCE(     (         SELECT SUM(bond_count) / COUNT(atom_id)         FROM (             SELECT COUNT(*) as bond_count, atom_id             FROM connected c             JOIN atom a ON c.atom_id = a.atom_id             WHERE a.element = 'i'             GROUP BY atom_id         ) AS subquery     ),     0 ) AS average_bonds; 
SELECT b.bond_type, b.bond_id FROM connected c JOIN bond b ON c.bond_id = b.bond_id WHERE SUBSTR(c.atom_id, 7, 2) = '45'; 
  SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected);
  SELECT a.atom_id FROM atom AS a JOIN bond AS b ON a.molecule_id = b.molecule_id WHERE a.molecule_id = 'TR041' AND b.bond_type = '#';
  SELECT atom.element  FROM connected  INNER JOIN atom ON connected.atom_id = atom.atom_id  WHERE connected.bond_id = 'TR144_8_19';
SELECT molecule_id AS CarcinogenicMolecule,         COUNT(bond_type) AS NumberOfDoubleBonds,        RANK() OVER (ORDER BY COUNT(bond_type) DESC) AS Rank FROM bond WHERE bond_type = '=' AND molecule_id IN (     SELECT molecule_id FROM molecule WHERE label = '+' ) GROUP BY molecule_id; 
  SELECT element, COUNT(*) AS count FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE label = '+' GROUP BY element HAVING count = (     SELECT MIN(count_min) FROM (         SELECT element, COUNT(*) AS count_min         FROM atom         JOIN molecule ON atom.molecule_id = molecule.molecule_id         WHERE label = '+'         GROUP BY element     ) AS min_counts ) ORDER BY count ASC;
SELECT DISTINCT a.atom_id FROM atom a  JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2  WHERE a.element != 'pb' AND (     SELECT COUNT(*) FROM atom WHERE element = 'pb' ) > 0; 
SELECT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '#'; 
SELECT      ap.atom1,     ap.atom2,     COUNT(*) AS count_pairs,     (COUNT(*) * 100.0 / total_bonds) AS percentage FROM (     SELECT c1.atom_id AS atom1, c2.atom_id AS atom2     FROM connected c1     JOIN connected c2 ON c1.bond_id = c2.bond_id AND c1.atom_id < c2.atom_id ) ap, (SELECT COUNT(*) as total_bonds FROM bond) tb GROUP BY ap.atom1, ap.atom2, tb.total_bonds ORDER BY count_pairs DESC, percentage DESC LIMIT 1; 
SELECT ROUND((SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) / COUNT(b.bond_id)) * 100, 5) AS proportion FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '-'; 
SELECT COUNT(*) AS total FROM atom WHERE element IN ('c', 'h'); 
  SELECT connected.atom_id2 FROM atom JOIN connected ON atom.atom_id = connected.atom_id WHERE atom.element = 's';
SELECT DISTINCT     b.type,     ab1.atom_id AS atom1,     ab2.atom_id AS atom2 FROM      bond b JOIN      atom_bond ab1 ON b.id = ab1.bond_id JOIN      atom_bond ab2 ON b.id = ab2.bond_id WHERE      ab1.atom_id < ab2.atom_id; 
  SELECT COUNT(DISTINCT a.element) FROM atom AS a JOIN (     SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '-' ) AS b ON a.molecule_id = b.molecule_id;
  SELECT COUNT(*) FROM `atom` WHERE `molecule_id` IN (SELECT DISTINCT `molecule_id` FROM `bond` WHERE `bond_type` = '#') AND `element` IN ('p', 'br');
SELECT bond.bond_id FROM bond  JOIN molecule ON bond.molecule_id = molecule.molecule_id  WHERE molecule.label = '+'; 
SELECT m.molecule_id  FROM molecule AS m  INNER JOIN bond AS b ON m.molecule_id = b.molecule_id  WHERE b.bond_type = '-' AND m.label = '-'; 
SELECT      (SUM(CASE WHEN a.element = 'cl' THEN 1 ELSE 0 END) * 100.0 / COUNT(a.atom_id)) AS percentage FROM      atom a WHERE      a.molecule_id IN (         SELECT DISTINCT b.molecule_id         FROM bond b         WHERE b.bond_type = '-'     ); 
  SELECT label AS label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002');
  SELECT molecule_id FROM molecule WHERE label = '-';
SELECT COUNT(*) FROM molecule WHERE label = '+' AND CAST(SUBSTRING(molecule_id, 3) AS UNSIGNED) BETWEEN 0 AND 30; 
  SELECT b.bond_type  FROM bond b INNER JOIN molecule m ON b.molecule_id = m.molecule_id WHERE m.molecule_id BETWEEN 'TR000' AND 'TR050' ORDER BY m.molecule_id;
  SELECT element FROM atom  JOIN connected ON atom.atom_id = connected.atom_id  WHERE bond_id = 'TR001_10_11';
  SELECT COUNT(bond.bond_id) AS count FROM bond WHERE bond.molecule_id IN (SELECT atom.molecule_id FROM atom WHERE atom.element = 'i');
SELECT      CASE          WHEN COUNT(CASE WHEN m.label = '+' THEN 1 END) > COUNT(*) / 2 THEN 'mostly carcinogenic'         ELSE 'mostly non-carcinogenic'     END AS result FROM (     SELECT DISTINCT a.molecule_id, m.label     FROM atom a     JOIN molecule m ON a.molecule_id = m.molecule_id     WHERE a.element = 'Ca' ) sub; 
SELECT * FROM `connected`  JOIN `atom` AS a1 ON `connected`.`atom_id` = a1.`atom__id`  JOIN `atom` AS a2 ON `connected`.`atom_id2` = a2.`atom_id`  WHERE `bond_id` = 'TR001_1_8' AND (a1.element = 'cl' AND a2.element = 'c') OR (a1.element = 'c' AND a2.element = 'cl'); 
  SELECT molecule.molecule_id FROM bond  JOIN molecule ON bond.molecule_id = molecule.molecule_id  JOIN atom ON molecule.molecule_id = atom.molecule_id  WHERE bond.bond_type = '#' AND molecule.label = '-' AND atom.element = 'c'  GROUP BY molecule.molecule_id  HAVING COUNT(bond.bond_type) >= 1 AND COUNT(atom.element) >= 1  LIMIT 2;
SELECT      (SUM(CASE WHEN atom.element = 'cl' THEN 1 ELSE 0 END) / COUNT(atom.molecule_id)) * 100 AS chlorine_percentage  FROM      atom  JOIN      molecule ON atom.molecule_id = molecule.molecule_id  WHERE      molecule.label = '+'; 
SELECT element FROM atom WHERE molecule_id = 'TR001'; 
SELECT molecule_id FROM bond WHERE bond_type = '='; 
SELECT c.atom_id, c.atom_id2  FROM connected AS c  INNER JOIN bond AS b ON c.bond_id = b.bond_id  WHERE b.bond_type = '#'; 
SELECT a.element  FROM connected c  JOIN atom a ON c.atom_id = a.atom_id  WHERE c.bond_id = 'TR000_1_2'; 
SELECT COUNT(*)  FROM bond  JOIN molecule ON bond.molecule_id = molecule.molecule_id  WHERE bond.bond_type = '-' AND molecule.label = '-'; 
SELECT m.label FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_id = 'TR001_10_11'; 
  SELECT      b.bond_id,      CASE WHEN m.label = '+' THEN 'carcinogenic' ELSE 'non-carcinogenic' END AS is_carcinogenic FROM      bond b JOIN      molecule m ON b.molecule_id = m.molecule_id WHERE      b.bond_type = '#';
SELECT a.element, COUNT(*) as count FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND substr(a.atom_id, 7, 1) = '4' GROUP BY a.element; 
SELECT m.label,         (COUNT(CASE WHEN a.element = 'h' THEN 1 END) / COUNT(a.element)) AS ratio  FROM atom a  JOIN molecule m ON a.molecule_id = m.molecule_id  WHERE m.molecule_id = 'TR006'; 
  SELECT COUNT(*) > 0 AS is_carcinogenic FROM `atom` a INNER JOIN `molecule` m ON a.molecule_id = m.molecule_id WHERE a.element = 'ca' AND m.label = '+';
  SELECT b.bond_type FROM bond b JOIN connected c ON b.bond_id = c.bond_id WHERE c.atom_id IN (SELECT a.atom_id FROM atom a WHERE a.element = 'c')    OR c.atom_id2 IN (SELECT a.atom_id FROM atom a WHERE a.element = 'c');
SELECT `element`  FROM `atom`  WHERE `atom_id` IN (     SELECT `atom_id`      FROM `connected`      WHERE `bond_id` = 'TR001_10_11' ) 
SELECT (COUNT(CASE WHEN bond_type = '#' THEN 1 END) / COUNT(*)) * 100 AS percentage; 
  SELECT      COUNT(CASE WHEN bond_type = '=' THEN 1 END) / COUNT(*) * 100 AS percent FROM      bond WHERE      molecule_id = 'TR047';
  SELECT `molecule`.`label` FROM `atom` JOIN `molecule` ON `atom`.`molecule_id` = `molecule`.`molecule_id` WHERE `atom`.`atom_id` = 'TR001_1';
  SELECT label FROM molecule WHERE molecule_id = 'TR151';
SELECT `element` FROM `atom` WHERE `molecule_id` = 'TR151'; 
  SELECT COUNT(*) FROM molecule WHERE label = '+';
  SELECT `atom_ii`, `molecule_id`, `element` FROM `atom` WHERE (substr(`molecule_id`, 3, 3) >= '10' AND substr(`molecule_id`, 3, 3) <= '50') AND `element` = 'c';
SELECT COUNT(*) AS num_atoms FROM atom  JOIN molecule ON atom.molecule_id = molecule.molecule_id  WHERE molecule.label = '+'; 
  SELECT bond_id FROM bond AS b JOIN molecule AS m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '=' AND m.label = '+';
  SELECT COUNT(*) FROM atom  LEFT JOIN molecule ON atom.molecule_id = molecule.molecule_id  WHERE atom.element = 'h' AND molecule.label = '+';
SELECT molecule_id FROM bond WHERE bond_id = 'TR000_1_2'; 
  SELECT a.* FROM atom a INNER JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'c' AND m.label = '-';
  SELECT      (COUNT(DISTINCT m.molecule_id) / COUNT(m2.molecule_id)) * 100.0 AS percentage FROM      molecule m JOIN      atom a ON m.molecule_id = a.molecule_id JOIN      molecule m2 ON m2.molecule_id = a.molecule_id WHERE      m.label = '+' AND a.element = 'h';
  SELECT label FROM molecule WHERE molecule_id = 'TR124';
  SELECT atom_id FROM atom WHERE molecule_id = 'TR186';
  SELECT bond_type FROM bond WHERE bond_id = 'TR007_4_19';
SELECT `element`  FROM `atom`  WHERE `atom_id` IN (     SELECT `atom_id`      FROM `connected`      WHERE `bond_id` = 'TR001_2_4' ); 
SELECT      (SELECT COUNT(*) FROM bond WHERE molecule_id = 'TR006' AND bond_type = '=') AS double_bonds,     (molecule.label = '+') AS is_carcinogenic  FROM molecule m  WHERE m.molecule_id = 'TR006'; 
SELECT m.molecule_id, GROUP_CONCAT(a.element) AS elements FROM molecule m  INNER JOIN atom a ON m.molecule_id = a.molecule_id  WHERE m.label = '+'  GROUP BY m.molecule_id; 
SELECT bond.bond_id, connected.atom_id, connected(atom_id2) FROM bond  JOIN connected ON bond.bond_id = connected.bond_id  WHERE bond.bond_type = '-'; 
SELECT a.molecule_id, GROUP_CONCAT(a.element) AS elements  FROM atom a  WHERE a.molecule_id IN (SELECT b.molecule_id FROM bond b WHERE b.bond_type = '#')  GROUP BY a.molecule_id; 
SELECT element FROM atom  WHERE atom_id IN (     SELECT atom_id FROM connected      WHERE bond_id = 'TR000_2_3' ); 
  SELECT COUNT(DISTINCT c.bond_id) FROM connected c JOIN atom a1 ON c.atom_1 = a1.atom_id  JOIN atom a2 ON c.atom_2 = a2.atom_id  WHERE a1.element = 'cl' OR a2.element = 'cl';
  SELECT a.atom_id, COUNT(DISTINCT b.bond_type) AS bond_types_count FROM atom a JOIN (     SELECT molecule_id, COUNT(DISTINCT bond_type) as cnt     FROM bond     WHERE molecule_id = 'TR000'     GROUP BY molecule_id ) as subq ON a.molecule_id = subq.molecule_id WHERE a.molecule_id = 'TR000';
SELECT COUNT(DISTINCT b.molecule_id) AS total_double_bond,         COUNT(DISTINCT m.molecule_id) AS carcinogenic_count  FROM bond b  LEFT JOIN molecule m ON b.molecule_id = m.molecule_id  WHERE b.bond_type = '=' AND m.label = '+'; 
SELECT COUNT(DISTINCT a.molecule_id) AS Count FROM atom a WHERE NOT EXISTS (     SELECT 1      FROM atom      WHERE molecule_id = a.molecule_id AND element = 'S' ) AND NOT EXISTS (     SELECT 1      FROM bond      WHERE molecule_id = a.molecule_id AND bond_type = '=' ); 
  SELECT m.label FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_id = 'TR001_2_4';
SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR001'; 
SELECT COUNT(*) FROM bond WHERE bond_type = '-'; 
SELECT m.molecule_id AS carcinogenic_molecule  FROM atom a  JOIN molecule m ON a.molecule_id = m.molecule_id  WHERE a.element = 'cl' AND m.label = '+'; 
SELECT DISTINCT a.molecule_id  FROM atom a  JOIN molecule m ON a.molecule_id = m.molecule_id  WHERE a.element = 'c' AND m.label = '-'; 
  SELECT (COUNT(DISTINCT a.molecule_id) /          (SELECT COUNT(*) FROM molecule WHERE label = '+')) * 100 AS percentage FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label = '+' AND a.element = 'cl';
SELECT A.molecule_id  FROM connected AS C  JOIN atom AS A ON C.atom_id = A.atom_id  WHERE C.bond_id = 'TR001_1_7'; 
  SELECT COUNT(DISTINCT element) FROM atom WHERE atom_id IN (SELECT atom_id FROM connected WHERE bond_id = 'TR001_3_4');
  SELECT DISTINCT `bond`.`bond_type` FROM `connected` JOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id` WHERE (`atom_id` = 'TR000_1' AND `atom_id2` = 'TR000_2') OR (`atom_id` = 'TR000_2' AND `atom_id2` = 'TR000_1');
  SELECT b.molecule_id FROM bond b JOIN connected c ON b.bond_id = c.bond_id WHERE c.atom_id = 'TR000_2' OR c(atom_id) = 'TR000_4';
  SELECT element FROM atom WHERE atom_id = 'TR000_1';
  SELECT label FROM molecule WHERE molecule_id = 'TR000';
SELECT (SUM(CASE WHEN bond_type = '-' THEN 1 ELSE 0 END) / COUNT(bond_id)) * 100.0 AS percentage FROM bond; 
SELECT COUNT(DISTINCT atom.molecule_id) AS count_carcinogenic_nitrogen_molecules  FROM atom  INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id  WHERE atom.element = 'n' AND molecule.label = '+'; 
SELECT a.molecule_id  FROM atom a  JOIN bond b ON a.molecule_id = b.molecule_id  WHERE a.element = 's' AND b.bond_type = '='; 
  SELECT m.molecule_id  FROM molecule m  JOIN atom a ON m.molecule_id = a.molecule_id  WHERE m.label = '-'  GROUP BY m.molecule_id  HAVING COUNT(a.atom_id) > 5;
  SELECT element FROM atom INNER JOIN bond ON atom.molecule_id = bond.molecule_id WHERE bond.bond_type = '=' AND atom.molecule_id = 'TR024';
  SELECT molecule.molecule_id  FROM atom  JOIN molecule ON atom.molecule_id = molecule.molecule_id  WHERE molecule.label = '+'  GROUP BY molecule.molecule_id  ORDER BY COUNT(atom.atom_id) DESC  LIMIT 1;
SELECT      (COUNT(DISTINCT CASE WHEN m.label = '+' AND a.element = 'h' AND b.bond_type = '#' THEN m.molecule_id END) / COUNT(DISTINCT CASE WHEN a.element = 'h' AND b.bond_type = '#' THEN m.molecule_id END)) * 100.0 AS percentage FROM      molecule m JOIN      atom a ON m.molecule_id = a.molecule_id JOIN      bond b ON m.molecule_id = b.molecule_id WHERE      a.element = 'h' AND b.bond_type = '#'; 
SELECT COUNT(*) FROM molecule WHERE label = '+'; 
  SELECT COUNT(DISTINCT `molecule_id`) FROM `bond` WHERE `molecule_id` BETWEEN 'TR004' AND 'TR010' AND `bond_type` = '-';
  SELECT COUNT(element) FROM atom WHERE molecule_id = 'TR008' AND element = 'c';
  SELECT `element` FROM `atom` WHERE `atom_ id` = 'TR004_7' AND `molecule_ id` IN (SELECT `molecule_ id` FROM `molecule` WHERE `label` = '-');
SELECT COUNT(DISTINCT a.molecule_id)  FROM atom AS a  JOIN bond AS b ON a.molecule_id = b.molecule_id  WHERE a.element = 'o' AND b.bond_type = '='; 
SELECT COUNT(DISTINCT m.molecule_id) AS count  FROM molecule m  INNER JOIN bond b ON m.molecule_id = b.molecule_id  WHERE b.bond_type = '#' AND m.label = '-'; 
  SELECT element FROM atom WHERE molecule_id = 'TR002' UNION SELECT bond_type FROM bond WHERE molecule_id = 'TR002';
  SELECT a.atom_id FROM atom a JOIN bond b ON a.molecule_id = b.molecule_id WHERE a.molecule_id = 'TR012' AND a.element = 'c' AND b.bond_type = '=';
SELECT atom_aid  FROM atom  JOIN molecule ON atom.molecule_aid = molecule.molecule_aid   WHERE molecule.label = '+' AND atom.element = 'o'; 
  SELECT * FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;
SELECT * FROM cards WHERE borderColor = 'borderless' AND cardKingdomId IS NULL; 
SELECT name FROM cards WHERE faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards); 
  SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = '2015';
  SELECT * FROM cards  JOIN legalities ON cards.uuid = legalities.uuid  WHERE cards.rarity = 'mythic' AND legalities.format = 'gladiator' AND legalities.status = 'Banned';
SELECT l.status  FROM legalities AS l  JOIN cards AS c ON l.uuid = c.uuid  WHERE c.type = 'Artifact' AND c.side IS NULL AND l.format = 'vintage'; 
SELECT c.id, c.artist FROM cards c  JOIN legalities l ON c.uuid = l.uuid  WHERE (c.power = '*' OR c.power IS NULL) AND l.format = 'commander' AND l.status = 'Legal'; 
SELECT c.id AS card_id, c.artist, c.hasContentWarning AS has_missing_degraded_properties, r.text AS ruling_text  FROM cards c  LEFT JOIN rulings r ON c.uuid = r.uuid  WHERE c.artist = 'Stephen Daniele'; 
  SELECT r.text FROM cards c INNER JOIN rulings r ON c.uuid = r.uuid WHERE c.name = 'Sublime Epiphany' AND c.number = '74s';
  WITH ruling_counts AS (     SELECT uuid, COUNT(*) as ruling_count     FROM rulings     GROUP BY uuid ), max_ruling AS (     SELECT MAX(ruling_count) as max_count     FROM ruling_counts ) SELECT c.name, c.artist, c.isPromo FROM cards c JOIN ruling_counts rc ON c.uuid = rc.uuid JOIN max_ruling mr ON rc.ruling_count = mr.max_count LIMIT 1;
SELECT f.language FROM cards AS c JOIN foreign_data AS f ON c.uuid = f.uuid WHERE c.name = 'annul' AND c.number = '29'; 
  SELECT c.name FROM cards AS c JOIN foreign_data AS fd ON c.uuid = fd.uuid WHERE fd.language = 'Japanese';
SELECT      (COALESCE(SUM(fd.id), 0) / COUNT(c.id)) * 100 AS percentage FROM      cards c LEFT JOIN      foreign_data fd ON c.uuid = fd.uuid AND fd.language = 'Chinese Simplified'; 
SELECT s.name, s.totalSetSize FROM sets AS s JOIN set_translations AS st ON s.code = st.setCode WHERE st.language = 'Italian'; 
  SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd';
  SELECT keywords FROM cards WHERE name = 'Angel of Mercy';
  SELECT COUNT(*) FROM cards WHERE power = '*';
  SELECT promoTypes FROM cards WHERE name = 'Duress';
  SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';
SELECT originalType  FROM cards  WHERE name = 'Ancestor''s Chosen'; 
  Certainly! Here is a structured and organized presentation of typical daily tasks for a data analyst:    ### Daily Tasks of a Data Analyst  1. **Data Collection and Cleaning**    - Gather raw data from various sources.    - Identify and handle missing or inconsistent data.    - Clean datasets to ensure accuracy and reliability.  2. **Exploratory Data Analysis (EDA)**    - Analyze patterns, trends, and anomalies in the data.    - Use statistical methods to summarize key findings.  3. **Statistical Analysis**    - Apply appropriate statistical techniques to test hypotheses.    - Identify correlations and relationships between variables.  4. **Data Visualization**    - Create clear and insightful charts, graphs, and dashboards.    - Use tools like Tableau, Power BI, or Python libraries (Matplotlib, Seaborn) for visualization.  5. **Predictive Modeling**    - Develop models using machine learning algorithms.    - Test and refine models to improve accuracy and performance.  6. **Reporting and Presentation**    - Prepare detailed reports summarizing findings.    - Present results to stakeholders in an accessible manner.  7. **Collaboration**    - Work with cross-functional teams to support data-driven decisions.    - Provide insights that inform business strategies.  8. **Documentation and Version Control**    - Maintain thorough documentation of processes and analyses.    - Use version control systems (e.g., Git) for code and reports.  9. **Continuous Learning**    - Stay updated on the latest tools, techniques, and industry trends.    - Engage in professional development to enhance skills.  10. **Performance Monitoring**     - Monitor KPIs and performance metrics.     - Provide feedback for process improvements based on data insights.    This list encompasses a broad range of responsibilities that contribute to effective data analysis and decision-making within an organization.
SELECT COUNT(*) AS total FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.status = 'Restricted' AND c.isTextless = 0; 
  SELECT r.text FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.name = "Condemn";
  SELECT COUNT(*)  FROM legalities l  INNER JOIN cards c ON l.uuid = c.uuid  WHERE c.isStarter = 1 AND l.status = 'Restricted';
  SELECT l.status FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE c.name = 'Cloudchaser Eagle';
  SELECT type FROM cards WHERE name = 'Benalish Knight';
  SELECT `legalities`.`format` FROM `cards` INNER JOIN `legalities` ON `cards`.`uuid` = `legalities`.`uuid` WHERE `cards`.`name` = 'Benalish Knight';
  SELECT cards.artist   FROM cards   INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid   WHERE foreign_data.language = 'Phyrexian';
SELECT (COUNT(CASE WHEN borderColor = 'borderless' THEN id END) / COUNT(id)) * 100 AS PercentageBorderless FROM cards; 
SELECT COUNT(DISTINCT c.id) AS Count  FROM cards c  JOIN foreign_data fd ON c.uuid = fd.uuid  WHERE c.isReprint = 1 AND fd.language = 'German'; 
  SELECT COUNT(c.id)  FROM cards c WHERE c.borderColor = 'borderless'  AND EXISTS (     SELECT 1      FROM foreign_data f      WHERE f.uuid = c.uuid      AND f.language = 'Russian' );
SELECT      (COUNT(CASE WHEN f.language = 'French' AND c.isStorySpotlight = 1 THEN c.id END) /       COUNT(CASE WHEN c.isStorySpotlight = 1 THEN c.id END)) * 100 AS percentage FROM cards c JOIN foreign__data f ON c.uuid = f.uuid; 
  SELECT COUNT(*) FROM cards WHERE toughness = '99';
  SELECT `name` FROM `cards` WHERE `artist` = 'Aaron Boyd';
  SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';
  SELECT `id` FROM `cards` WHERE `convertedManaCost` = 0;
  SELECT layout FROM cards WHERE keywords = 'flying';
SELECT COUNT(*) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'; 
SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL; 
  SELECT id FROM cards WHERE duelDeck = 'a';
SELECT edhrecRank FROM cards WHERE frameVersion = '2015'; 
SELECT c.artist FROM cards c JOIN foreign_data f ON c.uuid = f.uuid WHERE f.language = 'Chinese Simplified'; 
SELECT c.name FROM cards c JOIN foreign_data f ON c.uuid = f.uuid WHERE c.availability = 'paper' GROUP BY c.uuid HAVING COUNT(DISTINCT f.language) = 1  AND MAX(f.language) = 'Japanese'; 
  SELECT COUNT(*) FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE l.status = 'Banned' AND c.borderColor = 'white';
SELECT l.uuid AS legacy_uuid, f.language  FROM legalities l  JOIN foreign_data f ON l.uuid = f.uuid  WHERE l.format = 'legacy'; 
SELECT r.text  FROM rulings r  JOIN cards c ON r.uuid = c.uuid  WHERE c.name = 'Beacon of Immortality'; 
SELECT COUNT(c.id) AS future_frame_count  FROM cards c  JOIN legalities l ON c.uuid = l.uuid  WHERE c.frameVersion = 'future'; 
  SELECT cards.id, cards.colors   FROM cards   JOIN set_translations ON cards.setCode = set_ translations.setCode   WHERE cards.setCode = 'OGW';
  SELECT c.id, st.language  FROM cards c  JOIN set_translations st ON c.setCode = st.setCode  WHERE c.setCode = '10E' AND c.convertedManaCost = 5;
SELECT c.uuid AS card_identifier, r.ruling_text FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.originalType = 'Creature - Elf'; 
  SELECT cards.colors, legalities.format FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.id BETWEEN 1 AND 20;
  SELECT `cards`.`uuid` FROM `cards`  INNER JOIN `foreign_data` ON `cards`.`uuid` = `foreign_data`.`uuid`  WHERE `originalType` = 'Artifact' AND `colors` = 'B';
SELECT c.name FROM cards c LEFT JOIN rulings r ON c.uuid = r.uuid WHERE c.rarity = 'uncommon' GROUP BY c.uuid ORDER BY r.date ASC LIMIT 3; 
  SELECT COUNT(*) FROM cards WHERE artist = 'John Avon' AND (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL);
SELECT COUNT(*)  FROM cards  WHERE borderColor = 'white'  AND cardKingdomFoilId IS NOT NULL  AND cardKingdomId IS NOT NULL; 
  The provided database schema does not include the necessary columns for "availability" and "hand" size as mentioned in the question. Based on the available data, it is not possible to construct an accurate SQL query.  If additional tables or columns related to availability and hand size are present, please provide those details so that a correct SQL query can be generated.
  SELECT COUNT(*) FROM cards WHERE frameVersion = '1993' AND availability = 'paper' AND hasContentWarning = 1;
  SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability = 'mtgo,paper';
SELECT SUM(manaCost) FROM cards WHERE artist = 'Rob Alexander'; 
  SELECT      COALESCE(subtypes, '') || ', ' || COALESCE(supertypes, '') AS types FROM      cards WHERE      availability = 'arena';
  SELECT `setCode` FROM `set_translations` WHERE `language` = 'Spanish';
WITH      OnlineOnly AS (SELECT COUNT(*) as count_online FROM cards WHERE frameEffects = 'legendary' AND isOnlineOnly = 1),     TotalCards AS (SELECT COUNT(*) as total FROM cards WHERE frameEffects = 'legendary') SELECT (OnlineOnly.count_online * 100.0 / TotalCards.total) AS percentage FROM OnlineOnly, TotalCards; 
  SELECT COUNT(*) FROM cards WHERE isStorySpotlight=1 AND isTextless=0; SELECT id FROM cards WHERE isStorySpotlight=1 AND isTextless=0;
  SELECT name FROM foreign_data WHERE language = 'Spanish';
  SELECT language FROM set_translations JOIN sets ON set_translations.setCode = sets.code WHERE sets.baseSetSize = 309;
SELECT COUNT(DISTINCT s.id)  FROM sets s  JOIN set_ translations t ON s.code = t.setCode  WHERE s.block = 'Commander'  AND t.language = 'Portuguese (Brasil)'; 
SELECT c.id FROM cards c  JOIN legalities l ON c.uuid = l.uuid  WHERE c.types = 'Creature' AND l.status = 'Legal'  ORDER BY c.id; 
SELECT c.subtypes, c.supertypes  FROM cards c  INNER JOIN foreign__data f ON c.uuid = f.uuid  WHERE f.language = 'German' AND c.subtypes IS NOT NULL AND c.supertypes IS NOT NULL; 
SELECT COUNT(*)  FROM cards  WHERE (power IS NULL OR power = '*')  AND text LIKE '%triggered ability%'; 
SELECT COUNT(*) FROM cards c JOIN legalities l ON c.uuid = l.uuid JOIN rulings r ON c.uuid = r.uuid WHERE r.text = 'This is a triggered mana ability.' AND c.side IS NULL; 
  SELECT c.id  FROM cards c  JOIN legalities l ON c.uuid = l.uuid  WHERE c.artist = 'Erica Yang' AND c.availability = 'paper' AND l.format = 'pauper';
SELECT artist FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.flavorText = 'Das perfekte Gegenmittel zu einer dichten Formation'; 
  SELECT fd.name FROM cards c INNER JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.artist = 'Matthew D. Wilson' AND c.borderColor = 'black' AND c.layout = 'normal' AND c.types LIKE '%Creature%' AND fd.language = 'French';
SELECT COUNT(DISTINCT c.uuid) AS total_cards FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.rarity = 'rare' AND r.date = '2007-02-01'; 
  SELECT language  FROM set_translations  INNER JOIN sets ON set_Translations.setCode = sets.code  WHERE sets.baseSetSize = 180 AND sets.block = 'Ravnica';
  SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(l.uuid)) AS percentage   FROM cards c   JOIN legalities l ON c.uuid = l.uuid   WHERE l.format = 'commander' AND l.status = 'Legal';
SELECT      (COUNT(IF(f.language = 'French' AND (c.power IS NULL OR c.power = '*'), 1, NULL)) * 100.0 /       COUNT(IF(c.power IS NULL OR c.power = '*', 1, NULL))) AS percentage FROM cards c LEFT JOIN foreign_anguage_data f ON c.uuid = f.uuid; 
  SELECT (COUNT(CASE WHEN s.type = 'expansion' THEN 1 END) / COUNT(*)) * 100 AS percentage FROM set_translations t JOIN sets s ON t.setCode = s.code WHERE t.language = 'Japanese';
  SELECT availability FROM cards WHERE artist = 'Daren Bader';
  SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000;
SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isPromo = 1 AND isReprint = 1; 
SELECT name, power FROM cards WHERE (power IS NULL OR power = '*') AND promoTypes = 'arenaleague' ORDER BY name ASC LIMIT 3; 
  SELECT language FROM foreign_data WHERE multiverseid = 149934;
  SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId ASC LIMIT 3;
  SELECT (DIVIDE(COUNT(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 END), COUNT(CASE WHEN isTextless = 1 THEN 1 END)))*100 AS proportion;
SELECT id FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%'; 
SELECT mtgoCode, name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name LIMIT 3; 
  SELECT language FROM sets  JOIN set_translations ON sets.code = set_translations.setCode  WHERE sets.mcmName = 'Archenemy' AND set_translations.setCode = 'ARC';
  SELECT s.name, t.translation FROM sets s LEFT JOIN set_translations t ON s.code = t.setCode WHERE s.id = 5;
SELECT su.language, s.type  FROM set_uploads su LEFT JOIN sets s ON su.setcode = s.code  WHERE su.id = 206; 
  SELECT `id`, `name` FROM `sets` JOIN `set_translations` ON sets.`code` = set_translations.`setCode` WHERE `block` = 'Shadowmoor' AND `language` = 'Italian' ORDER BY `id` ASC, `name` ASC LIMIT 2;
  SELECT sets.id FROM sets WHERE sets.isForeignOnly = 1 AND sets.isFoilOnly = 1 AND EXISTS (SELECT 1 FROM set_translations WHERE set_translations.language = 'Japanese' AND set_translations.setCode = sets.code);
  SELECT sets.code FROM sets JOIN set_translations ON sets.code = set_translations.setCode WHERE set_translations.language = 'Russian' ORDER BY sets.baseSetSize DESC LIMIT 1;
SELECT      (COUNT(CASE WHEN s.isOnlineOnly = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'Chinese Simplified'; 
  SELECT COUNT(*) FROM sets s JOIN set_translations t ON s.code = t.setCode WHERE t.language = 'Japanese' AND (s.mtgoCode IS NULL OR s.mtgoCode = '')
  SELECT COUNT(*) AS total_black_borders, id FROM cards WHERE borderColor = 'black';
SELECT COUNT(*) FROM cards WHERE frameEffects = 'extendedart'; SELECT id FROM cards WHERE frameEffects = 'extendedart'; 
  SELECT * FROM cards WHERE borderColor = 'black' AND isFullArt = 1;
  SELECT language FROM set_translations WHERE id = 174;
SELECT name FROM sets WHERE code = 'ALL'; 
  SELECT language FROM foreign_data WHERE name = 'A Pedra Fellwar';
  SELECT code FROM sets WHERE releaseDate = '2007-07-13';
  SELECT baseSetSize, code FROM sets WHERE block IN ('Masques', 'Mirage');
SELECT code FROM sets WHERE type = 'expansion'; 
  SELECT fd.name AS "foreign_name", c.type FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.watermark = 'Boros';
SELECT fd.language, fd.flavorText, c.watermark AS type FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.watermark = 'colorpie'; 
SELECT      (SUM(CASE WHEN c.convertedManaCost = 10 THEN 1 ELSE 0 END) / COUNT(c.id)) * 100 AS percentage FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Abyssal Horror'; 
  SELECT code FROM sets WHERE type = 'commander';
  SELECT fd.name AS foreign_name, c.type FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.watermark = 'abzan';
SELECT fd.language, c.type  FROM cards c  JOIN foreign_data fd ON c.uuid = fd.uuid  WHERE c.watermark = 'Azorius'  LIMIT 1; 
  SELECT COUNT(*) FROM cards WHERE artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;
SELECT COUNT(*) FROM cards WHERE availability LIKE '%paper%' AND hand = '3'; 
  SELECT `name` FROM `cards` WHERE `isTextless` = 0;
SELECT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'; 
  SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND (power = '*' OR power IS NULL);
SELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL; 
  SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro- Sorcerer';
SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'; 
  SELECT COUNT(DISTINCT a.artist_id) AS artist_count FROM artists a JOIN card_artists ca ON a.artist_id = ca.artist_id WHERE c.availability LIKE '%arena,mtgo%'
SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper'); 
  SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';
  SELECT name FROM cards WHERE frameVersion = '2003' ORDER BY convertedManaCost DESC LIMIT 3;
SELECT translation FROM set_translations WHERE language = 'Italian' AND setCode = (SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen'); 
SELECT COUNT(*) FROM set_translations WHERE setCode = (SELECT setCode FROM cards WHERE name = 'Angel of Mercy'); 
  SELECT c.name FROM cards c JOIN set_translations t ON c.setCode = t.setCode WHERE t.translation = 'Hauptset Zehnte Edition'
  SELECT * FROM cards c JOIN set_translations t ON c.setCode = t.setCode WHERE c.name = 'Ancestor''s Chosen' AND t.language = 'Korean';
  SELECT COUNT(*) FROM cards c JOIN set_translations t ON c.setCode = t.setCode WHERE t.translation = "Hauptset Zehnte Edition" AND c.artist = "Adam Rex";
  SELECT sets.baseSetSize FROM sets JOIN set_translations ON sets.code = set_translations.setCode WHERE set_translations.translation = 'Hauptset Zehnte Edition';
  SELECT `translation` FROM `sets` s JOIN `set_translations` st ON s.`code` = st.`setCode` WHERE s.`name` = 'Eighth Edition' AND st.`language` = 'Chinese Simplified';
  SELECT `s`.`mtgoCode` FROM `cards` `c` JOIN `sets` `s` ON `c`.`setCode` = `s`.`code` WHERE `c`.`name` = 'Angel of Mercy' AND `s`.`mtgoCode` IS NOT NULL;
  SELECT s.releaseDate  FROM sets s  JOIN cards c ON s.code = c.setCode  WHERE c.name = 'Ancestor''s Chosen';
SELECT s.type  FROM sets AS s INNER JOIN set_translations AS st ON s.type = st.setCode WHERE st.translation = 'Hauptset Zehnte Edition'; 
SELECT COUNT(*)  FROM sets s  JOIN set_translations t ON s.code = t.setCode  WHERE s.block = 'Ice Age'  AND t.language = 'Italian'  AND t.translation IS NOT NULL; 
SELECT c.setName AS set_name, s.isForeignOnly AS is_foreign_only  FROM cards c  JOIN sets s ON c.set_code = s.code  WHERE c.name LIKE 'Adarkar Valkyrie%'  LIMIT 1; 
SELECT COUNT(*)  FROM sets s  JOIN set_translations st ON s.code = st.setCode  WHERE st.language = 'Italian'  AND st.translation IS NOT NULL  AND s.baseSetSize < 100; 
SELECT COUNT(*) FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Coldsnap' AND c.borderColor = 'black'; 
  SELECT c.name FROM (     SELECT cards.name, sets.name      FROM cards      INNER JOIN sets ON cards.setCode = sets.code      WHERE sets.name = 'Coldsnap' ) AS c GROUP BY c.name HAVING MAX(c.convertedManaCost);
SELECT DISTINCT c.artist  FROM cards c  JOIN sets s ON c.setCode = s.code  WHERE s.name = 'Coldsnap'  AND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy'); 
SELECT c.name, c.number  FROM cards c  JOIN sets s ON c.setCode = s.code  WHERE s.name = 'Coldsnap' AND c.number = 4; 
  SELECT COUNT(*) FROM cards c  JOIN sets s ON c.setCode = s.code  WHERE s.name = 'Coldsnap'  AND c.convertedManaCost > 5  AND (c.power = '*' OR c.power IS NULL);
  SELECT `foreign_data`.`flavorText` FROM `cards` INNER JOIN `foreign_data` ON `cards`.`uuid` = `foreign_data`.`uuid` WHERE `cards`.`name` = 'Ancestor''s Chosen' AND `foreign_data`.`language` = 'Italian';
SELECT language  FROM foreign_data  JOIN cards ON foreign_data.uuid = cards.uuid  WHERE name = 'Ancestor''s Chosen' AND flavorText IS NOT NULL; 
  SELECT `foreign__data`.`type` FROM `cards` JOIN `foreign__data` ON `cards`.`uuid` = `foreign_data`.`uuid` WHERE `cards`.`name` = 'Ancestor''s Chosen' AND `foreign_data`.`language` = 'German';
  SELECT c.name, c.setCode, fd.text FROM sets s JOIN cards c ON s.code = c.setCode JOIN foreign_data fd ON c.uuid = fd.uuid WHERE s.name = 'Coldsnap' AND fd.language = 'Italian';
SELECT fd.name  FROM foreign_data fd  JOIN cards c ON fd.uuid = c.uuid  JOIN sets s ON c.setCode = s.code  WHERE s.name = 'Coldsnap' AND fd.language = 'Italian'  AND c.convertedManaCost = (     SELECT MAX(convertedManaCost)      FROM cards      WHERE setCode = (SELECT code FROM sets WHERE name = 'Coldsnap') ); 
  SELECT date FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.name = 'Reminisce';
  SELECT      COUNT(c.id) / (SELECT COUNT(*) FROM cards c2 JOIN sets s2 ON c2.setCode = s2.code WHERE s2.name = 'Coldsnap') * 100 AS percentage FROM      cards c JOIN      sets s ON c.setCode = s.code WHERE      s.name = 'Coldsnap' AND c.convertedManaCost = 7;
  SELECT ((COUNT(c.id) WHERE c.cardKingdomFoilId IS NOT NULL AND c.cardKingdomId IS NOT NULL) / (COUNT(c.id) WHERE s.name = 'Coldsnap')) * 100 AS percentage FROM cards c JOIN sets s ON c.setCode = s.code;
  SELECT `code` FROM `sets` WHERE `releaseDate` = '2017-07-14';
  SELECT keyruneCode FROM sets WHERE code = 'PKHC';
  SELECT mcmId FROM sets WHERE code = 'SS2';
  SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';
  SELECT type FROM sets WHERE name = 'From the Vault: Lore';
  SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';
  SELECT c.uuid, c.artist, r.text AS ruling_text, c.hasContentWarning AS has_content_warning FROM cards c LEFT JOIN rulings r ON c.uuid = r.uuid WHERE c.artist = 'Jim Pavelec';
  SELECT sets.releaseDate FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE cards.name = 'Evacuation';
  SELECT sets.baseSetSize FROM sets JOIN set_translations ON sets.code = set_translations.setCode WHERE translation = 'Rinascita di Alara';
  SELECT type FROM sets INNER JOIN set_translations ON sets.code = set_translations.setCode WHERE set_translations.translation = 'HuitiÃ¨me Ã©dition';
SELECT translation  FROM set_translations  WHERE setCode = (SELECT setCode FROM cards WHERE name = 'Tendo Ice Bridge')  AND language = 'French'; 
SELECT COUNT(*)  FROM set_translations  JOIN sets ON set_translations.setCode = sets.code  WHERE sets.code = '10E' AND translation IS NOT NULL; 
SELECT translation FROM set_translations WHERE setCode = (SELECT setCode FROM cards WHERE name = 'Fellwar Stone') AND language = 'Japanese'; 
SELECT c.name  FROM cards AS c  INNER JOIN sets AS s ON c.setCode = s.code  WHERE s.name = 'Journey into Nyx Hero''s Path'  ORDER BY c.convertedManaCost DESC  LIMIT 1; 
SELECT s.releaseDate FROM sets AS s  INNER JOIN set_translations AS t ON s.code = t.setCode  WHERE t.translation = 'Ola de frÃ­o'; 
SELECT sets.type FROM cards, sets WHERE cards.setCode = sets.code AND cards.name = 'Samite Pilgrim'; 
  SELECT COUNT(*) FROM cards WHERE setCode IN (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') AND convertedManaCost = 3;
  SELECT st.translation FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE s.name = 'Mirrodin' AND st.language = 'Chinese Simplified';
  SELECT (SUM(s.isNonFoilOnly = 1) / SUM(t.language = 'Japanese')) * 100 AS percentage FROM sets s JOIN set_translations t ON s.code = t.setCode WHERE t.language = 'Japanese' AND t.setCode IS NOT NULL;
SELECT      (         COUNT(DISTINCT CASE WHEN s.isOnlineOnly = 1 THEN s.id END) * 100.0         / COUNT(DISTINCT s.id)     ) AS percentage FROM      set_translations st JOIN      sets s ON st.setCode = s.code WHERE      st.language = 'Portuguese (Brazil)'; 
  SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;
  SELECT id FROM sets WHERE baseSetSize = (SELECT MAX(baseSetSize) FROM sets);
SELECT DISTINCT artist FROM cards WHERE side IS NULL; 
SELECT MAX(frameEffects) FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL; 
  SELECT COUNT(*) FROM cards WHERE duelDeck = 'a' AND hasFoil = 0 AND (power IS NULL OR power = '*');
SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1; 
SELECT      CASE         WHEN manaCost = '' THEN 0         ELSE (                          SUM(CAST(SUBSTRING(                 REPLACE(REPLACE(manaCost, '{', ''), '}', ''),                 pos,                 1             ) AS UNSIGNED)) +                          (LENGTH(                 REPLACE(REPLACE(manaCost, '{', ''), '}', '')             ) - COUNT(CASE WHEN SUBSTRING(                 REPLACE(REPLACE(manaCost, '{', ''), '}', ''),                 pos,                 1             ) REGEXP '[0-9]' THEN 1 ELSE NULL END))         )     END AS CMC,     COUNT(*) AS count_of_cards FROM      your_table_name,     (SELECT pos FROM seq_1_to_50) p  WHERE      pos <= LENGTH(REPLACE(REPLACE(manaCost, '{', ''), '}', '')) GROUP BY      CMC; 
SELECT c.originalReleaseDate, l.format FROM cards c JOIN (     SELECT uuid FROM cards WHERE rarity = 'mythic' ORDER BY originalReleaseDate ASC LIMIT 1 ) AS oldest ON c.uuid = oldest.uuid JOIN legalities l ON c.uuid = l.uuid AND l.status = 'legal'; 
  SELECT COUNT(cards.id) FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.artist = 'Volkan BaÇµa' AND foreign_data.language = 'French';
SELECT COUNT(c.uuid) AS count FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.rarity = 'rare' AND c.types = 'Enchantment' AND c.name = 'Abundance' GROUP BY c.uuid HAVING SUM(CASE WHEN l.status != 'Legal' THEN 1 ELSE 0 END) = 0; 
SELECT l.format AS play_format, c.name AS card_name FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE l.status = 'Banned' GROUP BY l.format, c.name HAVING COUNT(l.status) = (     SELECT MAX(banned_count)     FROM (         SELECT COUNT(*) AS banned_count         FROM legalities         WHERE status = 'Banned'         GROUP BY format     ) AS max_bans ); 
  SELECT s.name, st.language FROM sets s JOIN set_uploads st ON s.id = st.id WHERE s.name = 'Battlebond';
SELECT c.artist AS Artist, l.format AS Format FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.artist IN (     SELECT artist     FROM cards     GROUP BY artist     HAVING COUNT(*) = (         SELECT MIN(cnt)         FROM (             SELECT COUNT(*) cnt             FROM cards             GROUP BY artist         ) t     ) ) GROUP BY c.artist, l.format; 
SELECT l.status FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.frameVersion = '1997' AND c.artist = 'D. Alexander Gregory' AND c.hasContentWarning = 1 AND l.format = 'legacy'; 
  SELECT c.name, l.format, l.status FROM cards c INNER JOIN legalities l ON c.uuid = l.uuid WHERE c.edhrecRank = 1 AND l.status = 'Banned';
SELECT      (COUNT(s.id) / 4.0) AS annual_avg,     MAX(COUNT(st.language)) OVER () AS common_language FROM sets s JOIN set_translations st ON s.id = st.id WHERE releaseDate BETWEEN '2012-01-01' AND '2015-12-31'; 
SELECT DISTINCT artist FROM cards WHERE availability = 'arena'; 
  SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'banned' OR status = 'restricted');
SELECT COUNT(*) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'; 
  SELECT r.text FROM rulings AS r JOIN cards AS c ON r.uuid = c.uuid WHERE c.artist = 'Kev Walker' ORDER BY r.date DESC;
SELECT DISTINCT c.name AS card_name, l.format  FROM cards c  JOIN legalities l ON c.uuid = l.uuid  JOIN sets s ON c.setCode = s.code  WHERE s.name = 'Hour of Devastation' AND l.status = 'Legal'; 
SELECT DISTINCT s.name FROM sets s JOIN set_translations kt ON s.code = kt.setCode AND kt.language = 'Korean' LEFT JOIN set_translations jt ON s.code = jt.setCode AND jt.language LIKE '%Japanese%' WHERE jt.setCode IS NULL; 
  SELECT      c.frameVersion,     c.name,     IF(l.status = 'Banned', 1, 0) AS is_banned FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.artist = 'Allen Williams';
SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'); 
SELECT DisplayName FROM users WHERE YEAR(CreationDate) = 2011; 
SELECT COUNT(`Id`) FROM `users` WHERE `LastAccessDate` > '2014-09-01'; 
SELECT DisplayName, Views FROM users ORDER BY Views DESC LIMIT 1; 
SELECT COUNT(*) FROM users WHERE Upvotes > 100 AND Downvotes > 1; 
SELECT COUNT(*) FROM users WHERE Views > 10 AND YEAR(CreationDate) > 2013; 
SELECT COUNT(p.Id) AS NumberOfPosts FROM posts p LEFT JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'csgillespie'; 
  SELECT `Title` FROM `posts`  JOIN `users` ON `posts`.`OwnerUserId` = `users`.`Id`  WHERE `users`.`DisplayName` = 'csgillespie';
  SELECT `DisplayName` FROM `users`  INNER JOIN `posts` ON `users`.`Id` = `posts`.`OwnerUserId`  WHERE `Title` = 'Eliciting priors from experts';
SELECT Title FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie') AND ViewCount = (SELECT MAX(ViewCount) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie')); 
SELECT users.DisplayName  FROM posts  INNER JOIN users ON posts.OwnerUserId = users.Id  WHERE posts.FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts); 
SELECT SUM(CommentCount) AS TotalComments  FROM posts  WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie'); 
SELECT MAX(AnswerCount)  FROM posts  WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie'); 
SELECT users.DisplayName  FROM posts  JOIN users ON posts.LastEditorUserId = users.Id  WHERE posts.Title = "Examples for teaching: Correlation does not mean causation"  ORDER BY posts.Id LIMIT 1; 
SELECT COUNT(*) FROM users u JOIN posts p ON u.Id = p.OwnerUserId WHERE u.DisplayName = 'csgillespie' AND p.ParentId IS NULL; 
SELECT DISTINCT u.DisplayName  FROM users u  JOIN posts p ON u.Id = p.OwnerUserId  WHERE p.ClosedDate IS NOT NULL; 
SELECT COUNT(*) FROM posts  INNER JOIN users ON posts.OwnerUserId = users.Id  WHERE users.Age > 65 AND posts.Score >= 20; 
SELECT u.Location  FROM posts p  JOIN users u ON p.OwnerUserId = u.Id  WHERE p.Title = 'Eliciting priors from experts'; 
SELECT p.Body  FROM tags t  JOIN posts p ON t.ExcerptPostId = p.Id  WHERE t.TagName = 'bayesian'; 
  SELECT Body FROM posts WHERE Id = (SELECT ExcerptPostId FROM tags WHERE Count = (SELECT MAX(Count) FROM tags));
SELECT COUNT(*) FROM badges  JOIN users ON badges.UserId = users.Id  WHERE users.DisplayName = 'csgillespie'; 
  SELECT b.Name FROM users u INNER JOIN badges b ON u.Id = b.UserId WHERE u.DisplayName = 'csgillespie';
  SELECT COUNT(*)  FROM badges  JOIN users ON badges.UserId = users.Id  WHERE users.DisplayName = 'csgillespie'  AND YEAR(badges.Date) = 2011;
  The SQL query to find the display name of the user with the most badges is as follows:  WITH BadgeCounts AS (     SELECT UserId, COUNT(*) as BadgeCount      FROM badges      GROUP BY UserId ), MaxBadgeCount AS (     SELECT MAX(BadgeCount) as MaxCount      FROM BadgeCounts ) SELECT u.DisplayName  FROM users u JOIN BadgeCounts bc ON u.Id = bc.UserId WHERE bc.BadgeCount = (SELECT MaxCount FROM MaxBadgeCount);
  SELECT AVG(Score)  FROM posts  JOIN users ON posts.OwnerUserId = users.Id  WHERE users.DisplayName = 'csgillespie';
  SELECT AVG(badge_count)  FROM (     SELECT COUNT(u.Id) as badge_count      FROM users u      LEFT JOIN badges b ON u.Id = b.UserId      WHERE u.Views > 200      GROUP BY u.Id )
WITH ElderOwnedPosts AS (     SELECT COUNT(p.Id) as ElderCount      FROM posts p      JOIN users u ON p.OwnerUserId = u.Id      WHERE p.Score > 5 AND u.Age > 65 ), TotalPostsOver5 AS (     SELECT COUNT(Id) as TotalCount      FROM posts      WHERE Score > 5 ) SELECT (ElderOwnedPosts.ElderCount * 100.0 / TotalPostsOver5.TotalCount) as Percentage FROM ElderOwnedPosts, TotalPostsOver5; 
SELECT COUNT(*) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'; 
SELECT CreationDate FROM votes WHERE COUNT(Id) = (SELECT MAX(COUNT(Id)) FROM votes GROUP BY CreationDate); 
SELECT COUNT(*) FROM badges WHERE Name = 'Revival'; 
SELECT p.Title  FROM posts p WHERE p.Id IN (     SELECT c.PostId      FROM comments c      WHERE c.Score = (SELECT MAX(Score) FROM comments) ); 
  SELECT COUNT(*) FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount = 1910);
  SELECT posts.FavoriteCount FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE comments.UserId = 3025 AND comments.CreationDate = '2014/04/23 20:29:39.0';
SELECT Text FROM comments WHERE PostId = (SELECT Id FROM posts WHERE ParentId = 107829 AND CommentCount = 1) LIMIT 1; 
  SELECT p.ClosedDate IS NOT NULL AS IsWellFinished FROM comments c JOIN posts p ON c.PostId = p.Id WHERE c.UserId = '23853' AND c.CreationDate = '2013-07-12 09:08:18.0';
  SELECT users.Reputation FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.Id = 65041;
SELECT COUNT(*) AS NumberOfPosts FROM posts p INNER JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Tiago Pasqualini'; 
  SELECT DisplayName FROM users INNER JOIN votes ON users.Id=votes.UserId WHERE votes.Id=6347;
  SELECT COUNT(votes.Id) FROM posts JOIN votes ON posts.Id = votes.PostId WHERE posts.Title = 'data visualization';
SELECT Name FROM badges  JOIN users ON badges.UserId = users.Id  WHERE users.DisplayName = 'DatEpicCoderGuyWhoPrograms'; 
SELECT      (SELECT COUNT(p.Id) FROM posts p WHERE p.OwnerUserId = 24) /      (SELECT COUNT(v.Id) FROM votes v WHERE v.UserId = 24) AS ratio; 
  SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/ or RapidMiner into Informatica PowerCenter/Developer';
  SELECT `Text` FROM `comments` WHERE `Score` = 17;
  SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';
  SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'SilentGhost';
SELECT users.DisplayName FROM comments JOIN users ON comments.UserId = users.Id WHERE comments.Text = 'thank you user93!'; 
SELECT c.Text  FROM comments c  JOIN users u  ON c.UserId = u.Id  WHERE u.DisplayName = 'A Lion'; 
SELECT users.DisplayName, users.Reputation  FROM posts  JOIN users ON posts.OwnerUserId = users.Id  WHERE posts.Title = 'Understanding what Dassault iSight is doing?'; 
  SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.Title = 'How does gentle boosting differ from AdaBoost?';
  SELECT DisplayName FROM users INNER JOIN badges ON users.Id = badges.UserId WHERE badges.Name = 'Necromancer' LIMIT 10;
  SELECT u.DisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Title = 'Open source tools for visualizing multi-dimensional data';
SELECT Title  FROM posts  WHERE LastEditorUserId = (SELECT Id FROM users WHERE DisplayName = 'Vebjorn Ljosa'); 
  SELECT SUM(posts.Score) AS TotalScore, users.WebsiteUrl FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Yevgeny';
  SELECT `postHistory`.`Comment` FROM `postHistory` JOIN `posts` ON `postHistory`.`PostId` = `posts`.`Id` WHERE `posts`.`Title` = 'Why square the difference instead of taking the absolute value in standard deviation?';
  SELECT p.Id, p.Title, SUM(v.BountyAmount) AS TotalBountyAmount   FROM posts p   JOIN votes v ON p.Id = v.PostId   WHERE p.Title LIKE '%data%'   GROUP BY p.Id, p.Title;
  SELECT u.DisplayName  FROM users u JOIN votes v ON u.Id = v.UserId WHERE v.BountyAmount = 50;
SELECT      p.Title,     c.Text AS Comment,     AVG(p.ViewCount) OVER() AS OverallAverageViewCount FROM      Posts p JOIN      Comments c ON p.PostId = c.PostId WHERE      p.Tags LIKE '%<humor>%'; 
SELECT COUNT(*) FROM comments WHERE UserId = 13; 
SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users); 
SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users); 
  SELECT COUNT(*) FROM badges WHERE Name = 'Supporter' AND YEAR(Date) = 2011;
SELECT COUNT(*)  FROM (SELECT UserId        FROM badges        GROUP BY UserId        HAVING COUNT(UserId) > 5); 
SELECT COUNT(DISTINCT u.Id)  FROM users u  JOIN badges b1 ON u.Id = b1.UserId AND b1.Name = 'Teacher' JOIN badges b2 ON u.Id = b2.UserId AND b2.Name = 'Supporter' WHERE u.Location = 'New York, NY'; 
  SELECT u.Id AS User_Id, u.Reputation FROM users u JOIN comments c ON u.Id = c.UserId WHERE c.PostId = 1 LIMIT 1;
WITH single_history_users AS (     SELECT UserId      FROM postHistory      GROUP BY UserId, PostId      HAVING COUNT(*) = 1 ) SELECT DISTINCT s.UserId  FROM single_history_users s  JOIN posts p ON s.UserId = p.Id  WHERE p.ViewCount >= 1000; 
SELECT Name  FROM badges  WHERE UserId IN (     SELECT UserId      FROM comments      GROUP BY UserId      HAVING COUNT(*) = (         SELECT MAX(c.CommentCount)          FROM (             SELECT COUNT(*) AS CommentCount              FROM comments              GROUP BY UserId         ) c     ) ); 
SELECT COUNT(users.Id) FROM users  INNER JOIN badges ON users.Id = badges.UserId  WHERE users.Location = 'India' AND badges.Name = 'Teacher'; 
SELECT      ((cnt_2010 / total_students) * 100 - (cnt_2011 / total_students) * 100) AS percentage_difference FROM (     SELECT          SUM(CASE WHEN YEAR(date) = 2010 AND name = 'Student' THEN 1 ELSE 0 END) AS cnt_2010,         SUM(CASE WHEN YEAR(date) = 2011 AND name = 'Student' THEN 1 ELSE 0 END) AS cnt_2011,         COUNT(CASE WHEN name = 'Student' THEN 1 ELSE NULL END) AS total_students     FROM your_table ) sub; 
SELECT PostHistoryTypeId FROM postHistory WHERE PostId = 3720 UNION SELECT COUNT(DISTINCT UserId) AS PostHistoryTypeId FROM comments WHERE PostId = 3720; 
SELECT p.*, (SELECT ViewCount FROM posts WHERE Id = 61217) AS Popularity  FROM postLinks pl  JOIN posts p ON pl.PostId = p.Id  WHERE pl.PostId = 61217; 
  SELECT p.Score, pl.LinkTypeId FROM posts p INNER JOIN postLinks pl ON p.Id = pl.PostId WHERE pl.LinkTypeId = 395;
SELECT p.Id AS PostID, GROUP_CONCAT(ph.UserId) AS UserID  FROM posts p  JOIN postHistory ph ON p.Id = ph.PostId  WHERE p.Score > 60  GROUP BY p.Id; 
  SELECT SUM(p.FavoriteCount) FROM posts p JOIN postHistory ph ON p.Id = ph.PostId WHERE ph.UserId = 686 AND YEAR(ph.CreationDate) = 2011;
WITH PostCounts AS (     SELECT OwnerUserId, COUNT(*) as NumPosts     FROM posts     GROUP BY OwnerUserId ) SELECT      COALESCE(SUM(u.UpVotes) / COUNT(u.Id), 0) as AvgUpVotes,     COALESCE(SUM(u.Age) / COUNT(u.Id), 0) as AvgAge FROM users u JOIN PostCounts pc ON u.Id = pc.OwnerUserId WHERE pc.NumPosts > 10; 
  SELECT COUNT(*) FROM badges WHERE Name = 'Announcer';
SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0'; 
  SELECT COUNT(*) FROM comments WHERE score > 60;
  SELECT `Text` FROM `comments` WHERE `CreationDate` = '2010-07-19 19:25:47.0';
  SELECT COUNT(Score) FROM posts WHERE Score = 10;
SELECT DISTINCT b.BadgeName FROM users u JOIN user_badges ub ON u.UserId = ub.UserId JOIN badges b ON ub.BadgeId = b.BadgeId WHERE u.Reputation = (SELECT MAX(Reputation) FROM users); 
  SELECT u.Reputation FROM users u INNER JOIN badges b ON u.Id = b.UserId WHERE b.Date = '2010-07-19 19:39:08.0';
  SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'Pierre';
  SELECT `Date`  FROM `badges`  JOIN `users` ON `badges`.`UserId` = `users`.`Id`  WHERE `users`.`Location` = 'Rochester, NY';
SELECT      (         (SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Teacher')          /          (SELECT COUNT(DISTINCT UserId) FROM badges)     ) * 100 AS percentage; 
  SELECT (COUNT(CASE WHEN u.Age BETWEEN 13 AND 18 THEN 1 END) / COUNT(b.UserId)) * 100 AS percentage FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Organizer';
SELECT Score FROM comments WHERE CreationDate = '2010-07-19 19:19:56.0'; 
SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:37:33.0'; 
  SELECT Age FROM users JOIN badges ON users.Id = badges.UserId WHERE Location = 'Vienna, Austria';
SELECT COUNT(*) FROM badges  JOIN users ON badges.UserId = users.Id  WHERE badges.Name = 'Supporter' AND users.Age BETWEEN 19 AND 65; 
  SELECT `Views` FROM `users` WHERE `Id` IN (SELECT `UserId` FROM `badges` WHERE `Date` = '2010-07-19 19:39:08.0');
SELECT u.* FROM users u WHERE EXISTS (     SELECT 1      FROM badges b      WHERE b.userid = u.id AND b.name = 'Teacher' ) AND u.id > 100; 
SELECT badges.Name FROM badges  JOIN users ON badges.UserId = users.Id  WHERE users.DisplayName = 'Sharpie'; 
  SELECT COUNT(*) FROM badges b INNER JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Supporter' AND u.Age > 65;
  SELECT DisplayName FROM users WHERE Id = 30;
SELECT COUNT(Id) FROM users WHERE Location = 'New York, NY'; 
  SELECT COUNT(*) FROM votes WHERE YEAR(CreationDate) = 2010;
  SELECT COUNT(*) FROM users WHERE Age BETWEEN 19 AND 65;
  SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users);
  SELECT      (COUNT(*) WHERE YEAR(CreationDate) = 2010) /      (COUNT(*) WHERE YEAR(CreationDate) = 2011) AS vote_ratio_2010_2011  FROM votes;
SELECT DISTINCT t.TagName FROM posts p JOIN users u ON p.OwnerUserId = u.Id CROSS JOIN LATERAL (     SELECT substring(tag_part, 2, length(tag_part) - 2) AS tag_name     FROM unnest(string_to_array(p.Tags, '><')) AS tag_part ) s(tag_name) LEFT JOIN tags t ON s.tag_name = t.TagName WHERE u.DisplayName = 'John Salvatier'; 
  SELECT COUNT(*)  FROM postHistory  JOIN users ON postHistory.UserId = users.Id  WHERE users.DisplayName = 'Daniel Vassallo';
  SELECT COUNT(*) FROM votes WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Harlan');
SELECT Id  FROM posts  WHERE Id IN (     SELECT DISTINCT PostId      FROM postHistory      WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'slashnick') ) ORDER BY AnswerCount DESC LIMIT 1; 
SELECT u.DisplayName, SUM(p.ViewCount) AS TotalViews  FROM postHistory h  JOIN users u ON h.UserId = u.Id  JOIN posts p ON h.PostId = p.Id  WHERE u.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')  GROUP BY u.DisplayName  ORDER BY TotalViews DESC  LIMIT 1; 
SELECT COUNT(DISTINCT ph.PostId) FROM postHistory ph  JOIN users u ON ph.UserId = u.Id  WHERE u.DisplayName = 'Matt Parker' AND ph.PostId > 4; 
  SELECT COUNT(DISTINCT c.Id) AS NegativeCommentsCount FROM users u JOIN posts p ON u.Id = p.OwnerUserId JOIN comments c ON p.Id = c.PostId WHERE u.DisplayName = 'Neil McGuigan' AND c.Score < 60;
SELECT DISTINCT      substring_index(substring_index(p.Tags, '>', n), '<', -1) AS Tag FROM      postHistory h JOIN      users u ON h.UserId = u.Id AND u.DisplayName = 'Mark Meckes' JOIN      posts p ON h.PostId = p.Id AND p.CommentCount = 0 WHERE      p.Tags IS NOT NULL AND      substring_index(substring_index(p.Tags, '>', n), '<', -1) != '' GROUP BY      Tag; 
SELECT DISTINCT u.DisplayName  FROM users u  JOIN badges b ON u.Id = b.UserId  WHERE b.Name = 'Organizer'; 
SELECT CAST(COUNT(*) AS FLOAT) / (SELECT COUNT(*) FROM postHistory WHERE UserId = -1) * 100 AS percentage  FROM tags  WHERE TagName = 'r' AND ExcerptPostId IN (SELECT PostId FROM postHistory WHERE UserId = -1); 
SELECT      (SELECT SUM(ViewCount) FROM posts WHERE OwnerDisplayName = 'Mornington') -      (SELECT SUM(ViewCount) FROM posts WHERE OwnerDisplayName = 'Amos'); 
SELECT COUNT(*) FROM badges WHERE Name = 'Commentator' AND YEAR(Date) = 2014; 
SELECT COUNT(*) FROM postHistory WHERE CreationDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59'; 
SELECT DisplayName, Age FROM users WHERE Views = (SELECT MAX(Views) FROM users); 
  SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';
SELECT COUNT(*) FROM comments WHERE UserId = 13 AND Score < 60; 
  SELECT posts.Title, comments.UserDisplayName  FROM posts  INNER JOIN comments ON posts.Id = comments.PostId  WHERE comments.Score > 60;
  SELECT b.Name  FROM badges b JOIN users u ON b.UserId = u.Id WHERE YEAR(b.Date) = 2011 AND u.Location = 'North Pole';
SELECT u.DisplayName, u.WebsiteUrl  FROM users u  JOIN posts p ON u.Id = p.OwnerUserId  WHERE p.FavoriteCount > 150; 
  SELECT p.Title, COUNT(ph.Id) AS Count, p.LastEditDate FROM posts p JOIN postHistory ph ON p.Id = ph.PostId WHERE p.Title = 'What is the best introductory Bayesian statistics textbook?' GROUP BY p.Title ORDER BY Count DESC;
  SELECT u.LastAccessDate, u.Location FROM users u INNER JOIN badges b ON u.Id = b.UserId WHERE b.Name = 'Outliers';
SELECT rp.Title AS RelatedPostTitle FROM postLinks pl JOIN posts p ON pl.PostId = p.Id JOIN posts rp ON pl.RelatedPostId = rp.Id WHERE p.Title = 'How to tell if something happened in a data set which monitors a value over time'; 
SELECT ph.PostId, b.Name  FROM postHistory ph  JOIN badges b ON ph.UserId = b.UserId  WHERE ph.UserDisplayName = 'Samuel'  AND YEAR(ph.CreationDate) = 2013  AND YEAR(b.Date) = 2013; 
SELECT users.DisplayName  FROM posts  JOIN users ON posts.OwnerUserId = users.Id  WHERE posts.ViewCount = (SELECT MAX(ViewCount) FROM posts); 
  SELECT users.DisplayName, users.Location  FROM tags  JOIN posts ON tags.ExcerptPostId = posts.Id  JOIN users ON posts.OwnerUserId = users.Id  WHERE tags.TagName = 'hypothesis-testing';
  SELECT p.Title AS RelatedPostTitle, pl.LinkTypeId   FROM postLinks pl   JOIN posts p ON pl.RelatedPostId = p.Id   WHERE pl.PostId = (SELECT Id FROM posts WHERE Title = 'What are principal component scores?');
SELECT u.DisplayName  FROM posts p_child JOIN posts p_parent ON p_child.ParentId = p_parent.Id JOIN users u ON p_parent.OwnerUserId = u.Id WHERE p_child.ParentId IS NOT NULL ORDER BY p_child.Score DESC LIMIT 1; 
  SELECT users.DisplayName, users.WebsiteUrl FROM users JOIN votes ON users.Id = votes.UserId WHERE votes.VoteTypeId = 8 AND votes.BountyAmount = (SELECT MAX(BountyAmount) FROM votes WHERE VoteTypeId = 8);
  SELECT Title FROM posts WHERE ViewCount IS NOT NULL ORDER BY ViewCount DESC LIMIT 5;
  SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;
SELECT OwnerUserId  FROM posts  WHERE FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts); 
SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users); 
  SELECT COUNT(DISTINCT v.PostId) FROM posts p INNER JOIN votes v ON p.Id = v.PostId WHERE YEAR(v.CreationDate) = 2011 AND v.BountyAmount = 50;
SELECT Id FROM users GROUP BY Age HAVING Age = MIN(Age); 
SELECT SUM(Score) FROM posts WHERE LastActivityDate LIKE '2010-07-19%'; 
SELECT COUNT(pl.Id) / 12 AS average_monthly_links FROM postLinks pl INNER JOIN posts p ON pl.PostId = p.Id WHERE YEAR(pl.CreationDate) = 2010 AND (p.AnswerCount <= 2 OR p.AnswerCount IS NULL); 
  SELECT Id FROM posts WHERE Id IN (SELECT PostId FROM votes WHERE UserId = 1465) ORDER BY FavoriteCount DESC LIMIT 1;
SELECT p.Title FROM posts AS p WHERE p.Id IN (     SELECT l.PostId     FROM postLinks AS l ) AND p.CreationDate = (     SELECT MIN(p2.CreationDate)     FROM posts AS p2     WHERE p2.Id IN (         SELECT l2.PostId         FROM postLinks AS l2     ) ); 
SELECT u.DisplayName  FROM users u  JOIN (     SELECT UserId      FROM badges      GROUP BY UserId      HAVING COUNT(*) = (         SELECT MAX(cnt)          FROM (             SELECT COUNT(*) as cnt              FROM badges              GROUP BY UserId         ) max_counts     ) ) badge_max ON u.Id = badge_max.UserId; 
SELECT MIN(CreationDate) FROM votes WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'chl'); 
WITH eligible_users AS (     SELECT u.Id      FROM users u      WHERE u.Age IS NOT NULL AND EXISTS (         SELECT 1          FROM posts p          WHERE p.OwnerUserId = u.Id     ) ), min_age_value AS (     SELECT MIN(Age) AS min_age      FROM users      WHERE Id IN (SELECT Id FROM eligible_users) ) SELECT MIN(p.CreationDate) AS earliest_post_date FROM posts p  WHERE p.OwnerUserId IN (     SELECT u.Id      FROM users u      WHERE u.Age = (SELECT min_age FROM min_age_value) ); 
  SELECT users.DisplayName FROM badges JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Autobiographer' AND badges.Date = (     SELECT MIN(Date)     FROM badges     WHERE Name = 'Autobiographer' );
  SELECT COUNT(u.Id) FROM users u INNER JOIN posts p ON u.Id = p.OwnerUserId WHERE u.Location = 'United Kingdom' GROUP BY u.Id HAVING MAX(COALESCE(p.FavoriteCount, 0)) >=4;
SELECT AVG(v.PostId)  FROM users u  JOIN votes v ON u.Id = v.UserId  WHERE u.Age = (SELECT MAX(Age) FROM users); 
SELECT DisplayName FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users); 
  SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000;
SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65; 
  SELECT COUNT(*) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Jay Stevens' AND YEAR(p.CreationDate) = 2010;
  SELECT p.Id, p.Title FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Harvey Motulsky' ORDER BY p.ViewCount DESC LIMIT 1;
SELECT Id, Title FROM posts WHERE Score = (SELECT MAX(Score) FROM posts); 
SELECT AVG(p.Score) AS AverageScore  FROM posts p  JOIN users u ON p.OwnerUserId = u.Id  WHERE u.DisplayName = 'Stephen Turner'; 
SELECT users.DisplayName  FROM posts  INNER JOIN users ON posts.OwnerUserId = users.Id  WHERE posts.ViewCount > 20000 AND YEAR(posts.CreationDate) = 2011; 
SELECT p.Id, u.DisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE YEAR(u.CreationDate) = 2010 AND p.FavoriteCount = (     SELECT MAX(p2.FavoriteCount)     FROM posts p2     JOIN users u2 ON p2.OwnerUserId = u2.Id     WHERE YEAR(u2.CreationDate) = 2010 ); 
WITH counts AS (   SELECT      COUNT(p.Id) as total_count,     COUNT(CASE WHEN YEAR(p.CreationDate) = 2011 AND u.Reputation > 1000 THEN p.Id END) as qualified_count   FROM posts p   LEFT JOIN users u ON p.OwnerUserId = u.Id ) SELECT    COALESCE((qualified_count / total_count * 100), 0) as percentage FROM counts; 
SELECT (COUNT(CASE WHEN Age BETWEEN 13 AND 18 THEN Id END) * 100.0 / COUNT(Id)) AS percentage FROM users; 
  SELECT p.ViewCount AS TotalViews, u.DisplayName   FROM posts p   JOIN postHistory ph ON ph.PostId = p.Id   JOIN users u ON u.Id = p.LastEditorUserId   WHERE ph.Text = 'Computer Game Datasets';
SELECT COUNT(*) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts); 
SELECT COUNT(*) FROM comments  WHERE PostId = (SELECT Id FROM posts WHERE Score = (SELECT MAX(Score) FROM posts)); 
SELECT COUNT(*) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0; 
  SELECT u.DisplayName, u.Location  FROM users AS u  WHERE u.Id = (     SELECT p.OwnerUserId      FROM posts AS p      WHERE p.Id = 183 AND p.LastEditDate IS NOT NULL      ORDER BY p.LastEditDate DESC      LIMIT 1 );  The SQL query starts by selecting the `DisplayName` and `Location` from the `users` table. It then uses a subquery to find the `OwnerUserId` from the `posts` table where the `Id` is 183, orders them by `LastEditDate` in descending order (so that the latest edit comes first), and limits the result to one row. This ensures that we get the user who was the last to edit the post with ID 183.
SELECT * FROM badges  JOIN users ON badges.UserId = users.Id  WHERE DisplayName = 'Emmett' AND Date = (     SELECT MAX(Date) FROM badges      WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'Emmett') ); 
  SELECT COUNT(*) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000;
SELECT (b.Date - u.CreationDate) AS Duration FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'Zolomon'; 
SELECT      (SELECT COUNT(*) FROM posts WHERE OwnerUserId = u.Id) AS NumberOfPosts,     (SELECT COUNT(*) FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.OwnerUserId = u.Id) AS NumberOfComments FROM users u WHERE u.CreationDate = (SELECT MAX(CreationDate) FROM users); 
SELECT c.Text AS CommentText, u.DisplayName  FROM comments c  JOIN users u ON c.UserId = u.Id  WHERE c.PostId = (SELECT p.Id FROM posts p WHERE p.Title = 'Analysing wind data with R')  ORDER BY c.CreationDate DESC  LIMIT 10; 
  SELECT COUNT(*) FROM badges WHERE Name = 'Citizen Patrol';
  SELECT COUNT(*) FROM tags WHERE TagName = 'careers';
  SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';
  SELECT `AnswerCount`, `CommentCount` FROM `posts` WHERE `Title` = 'Clustering 1D data';
SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'; 
SELECT COUNT(*) FROM votes WHERE BountyAmount >= 30; 
  SELECT      (COUNT(CASE WHEN p.Score > 50 THEN p.Id END) * 100.0 / COUNT(p.Id)) AS percentage FROM      posts p WHERE      p.OwnerUserId IN (         SELECT u.Id          FROM users u          WHERE u.Reputation = (             SELECT MAX(Reputation)              FROM users         )     );  The SQL query calculates the percentage of posts by the most influential user (based on reputation) that have a score above 50.  **Step-by-Step Explanation:**  1. **Identify Most Influential User(s):**    - The subquery `SELECT MAX(Reputation) FROM users` finds the highest reputation value.    - Another subquery `SELECT u.Id FROM users u WHERE u.Reputation = (SELECT MAX(Reputation) FROM users)` retrieves all user IDs with this maximum reputation.  2. **Filter Posts by These Users:**    - The main query filters posts where `OwnerUserId` is in the set of most influential users identified above.  3. **Count Relevant Posts:**    - `COUNT(CASE WHEN p.Score > 50 THEN p.Id END)` counts the number of posts with a score over 50.    - `COUNT(p.Id)` counts all posts by these users, regardless of score.  4. **Calculate Percentage:**    - The percentage is computed as `(Count_Score_Above_50 / Total_Count) * 100`.    - Multiplying by `100.0` ensures the result is a float for accurate percentage representation.    - If there are no posts, this returns `NULL`; to handle division by zero, additional logic could be added, but it's not included here.  **Result:** The query returns the percentage of posts with scores above 50 from the most influential user(s), providing insight into their engagement quality.
SELECT COUNT(*) FROM posts WHERE Score < 20; 
  SELECT COUNT(*) FROM tags WHERE Id < 15 AND Count <= 20;
  SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';
  SELECT u.Reputation, u.UpVotes FROM comments c  INNER JOIN users u ON c.UserId = u.Id  WHERE c.Text = 'fine, you win :)';
  SELECT c.Text FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.Title LIKE '%linear regression%';
SELECT c.Text  FROM comments c  JOIN posts p ON c.PostId = p.Id  WHERE p.ViewCount BETWEEN 100 AND 150  AND c.Score = (     SELECT MAX(c2.Score)      FROM comments c2      WHERE c2.PostId = p.Id ); 
  SELECT u.CreationDate, u.Age  FROM users u  JOIN comments c ON u.Id = c.UserId  WHERE c.Comment LIKE '%http://%';
SELECT COUNT(*)  FROM comments  JOIN posts ON comments.PostId = posts.Id  WHERE comments.Score = 0 AND posts.ViewCount < 5; 
SELECT COUNT(*)  FROM posts  JOIN comments ON posts.Id = comments.PostId  WHERE posts.CommentCount = 1 AND comments.Score = 0; 
SELECT COUNT(u.Id)  FROM comments c  INNER JOIN users u ON c.UserId = u.Id  WHERE c.Score = 0 AND u.Age = 40; 
  SELECT p.Id AS PostID, c.Text AS Comment FROM posts p JOIN comments c ON p.Id = c.PostId WHERE p.Title = 'Group differences on a five point Likert item';
  SELECT u.UpVotes FROM comments AS c JOIN users AS u ON c.UserId = u.Id WHERE c.Text = 'R is also lazy evaluated';
  SELECT c.Text FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'Harvey Motulsky';
SELECT DISTINCT u.DisplayName  FROM users u  JOIN comments c ON u.Id = c.UserId  WHERE c.Score BETWEEN 1 AND 5  AND u.DownVotes = 0; 
  SELECT      ROUND(         (COUNT(CASE WHEN users.UpVotes = 0 THEN comments.UserId END) * 100.0 / COUNT(comments.UserId))          , 2     ) AS percentage FROM      comments  JOIN      users ON comments.UserId = users.Id  WHERE      comments.Score BETWEEN 5 AND 10;
  SELECT `superpower`.`power_name` FROM `superhero` AS `s` INNER JOIN `hero_power` AS `hp` ON `s`.`id` = `hp`.`hero_id` INNER JOIN `superpower` AS `sp` ON `hp`.`power_id` = `sp`.`id` WHERE `s`.`superhero_name` = '3- D Man';
  SELECT COUNT(DISTINCT hp.hero_id)  FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id  WHERE sp.power_name = 'Super Strength';
  Here is the SQL query to answer the question:  SELECT COUNT(superhero.id) AS count FROM superhero  INNER JOIN hero_power ON superhero.id = hero_power.hero_id WHERE superhero.height_ > 200 AND hero_power.power_id IN (     SELECT id FROM superpower WHERE power_name = 'Super Strength' );
  SELECT full_name FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id GROUP BY superhero.id HAVING COUNT(hero_power.hero_id) > 15;
SELECT COUNT(*)  FROM superhero  JOIN colour ON superhero.eye_colour_id = colour.id  WHERE colour.colour = 'Blue'; 
  SELECT colour.colour FROM superhero INNER JOIN colour ON superhero.skin_colour_id = colour.id WHERE superhero.superhero_name = 'Apocalypse';
SELECT COUNT(DISTINCT s.id) AS count FROM superhero s JOIN colour c ON s.eye_colour_id = c.id JOIN hero_power hp ON s.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE c.colour = 'Blue' AND sp.power_name = 'Agility'; 
  SELECT superhero_name FROM superhero JOIN colour e ON superhero.eye_Colour_id = e.id AND e.colour = 'Blue' JOIN colour h ON superhero.hair_Colour_id = h.id AND h.colour = 'Blond';
  SELECT COUNT(*) FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name = 'Marvel Comics';
SELECT RANK() OVER (ORDER BY height_ DESC) AS rank, superhero_id, superhero_name FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher_name = 'Marvel Comics' ORDER BY height_ DESC; 
  SELECT `publisher_ename` FROM `publisher` JOIN `superhero` ON `publisher`.`id` = `superhero`.`publisher_id` WHERE `superhero`.`superhero_ename` = 'Sauron';
SELECT c.colour AS 'Eye Color', COUNT(s.id) AS Count  FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  JOIN colour c ON s.eye_color_id = c.id  WHERE p.publisher_name = 'Marvel Comics'  GROUP BY c.colour  ORDER BY Count DESC; 
SELECT AVG(s.height_cm) AS average_height FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  WHERE p.publisher_name = 'Marvel Comics'; 
SELECT s.superhero_name  FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  WHERE p.publisher_name = 'Marvel Comics'  AND s.superhero_id IN (     SELECT hp.hero_id      FROM hero_power hp      JOIN superpower sp ON hp.power_id = sp.id      WHERE sp.power_name = 'Super Strength' ); 
SELECT COUNT(superhero.id) FROM superhero  JOIN publisher ON superhero.publisher_id = publisher.id  WHERE publisher.publisher_name = 'DC Comics'; 
  SELECT pub.publisher_name FROM hero_attribute h_attr JOIN superhero s_hero ON h_attr.hero_id = s_hero.id JOIN publisher pub ON s_hero.publisher_id = pub.id WHERE h_attr.attribute_id = 3 AND h_attr.attribute_value = (     SELECT MIN(ha.attribute_value)     FROM hero_attribute ha     WHERE ha.attribute_id = 3 );
SELECT COUNT(*) FROM superhero  JOIN colour ON superhero.eye_colour_id = colour.id  JOIn publisher ON superhero.publisher_ id = publisher.id  WHERE colour.colour = 'Gold' AND publisher.publisher_name = 'Marvel Comics'; 
  SELECT p.publisher_name FROM publisher p JOIN superhero s ON p.id = s.publisher_id WHERE s.superhero_name = 'Blue Beetle II';
  Here is the SQL query written based on the thought process:  SELECT COUNT(*) FROM superhero INNER JOIN colour ON superhero.hair_colour_id = colour.id WHERE colour.colour = 'Blond';
SELECT s.superhero_name  FROM superhero s  JOIN hero_attribute h ON s.id = h.hero_id  WHERE h.attribute_id = 1 AND h.attribute_value = (     SELECT MIN(attribute_value)      FROM hero_attribute      WHERE attribute_id = 1 ); 
  SELECT r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.superhero_name = 'Copycat';
SELECT s.name  FROM superhero s JOIN hero_attribute ha ON s.id = ha.hero_id WHERE ha.attribute_id = 1 AND ha.attribute_value < 50; 
SELECT sh.superhero_name  FROM superhero sh  JOIN hero_power hp ON sh.id = hp.hero_id  JOIN superpower sp ON hp.power_id = sp.id  WHERE sp.power_name = 'Death Touch'; 
  SELECT COUNT(*) FROM superhero  JOIN gender ON superhero.gender_id = gender.id  JOIN hero_attribute ON superhero.id = hero_attribute.hero_id  WHERE gender.gender = 'Female' AND hero_attribute.attribute_id = 2 AND hero_attribute.attribute_value = 100;
SELECT s.superhero_name  FROM superhero s  INNER JOIN hero_power hp ON s.id = hp.hero_id  GROUP BY s.superhero_name  ORDER BY COUNT(*) DESC  LIMIT 1; 
SELECT COUNT(*) FROM superhero s  JOIN race r ON s.race_id = r.id  WHERE r.race = 'Vampire'; 
SELECT      COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN s.id END) AS marvel_bad_alignment_count,     (SUM(CASE WHEN a.alignment = 'Bad' THEN 1 ELSE 0 END) / COUNT(s.id)) * 100 AS percentage_bad_alignment FROM      superhero s JOIN      publisher p ON s.publisher_id = p.id JOIN      alignment a ON s.alignment_id = a.id; 
SELECT      (SUM(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) -       SUM(CASE WHEN p.publisher_name = 'DC Comics' THEN 1 ELSE 0 END)) AS difference FROM superhero s JOIN publisher p ON s.publisher_id = p.id; 
  To find the publisher ID of Star Trek based on the provided schema and data:  **Step-by-Step Explanation:**  1. **Understand the Table Structure:**    - The `publisher` table has two columns:      - `id`: Unique identifier for each publisher (Primary Key)      - `publisher_name`: Text field that holds the name of the publisher  2. **Identify the Required Information:**    - We need to find the `id` where the `publisher_name` is 'Star Trek'.  3. **Formulate the SQL Query:**    - Use a SELECT statement to retrieve the `id`.    - Apply a WHERE clause to filter records where `publisher_name` equals 'Star Trek'.  4. **Consider the Data Provided:**    - Observing the data, there's no entry with `publisher_name` as 'Star Trek'.    - Therefore, this query will return an empty result set.  **SQL Query:**  SELECT id FROM publisher WHERE publisher_name = 'Star Trek';
SELECT AVG(attribute_value) FROM hero_attribute; 
SELECT COUNT(*) FROM superhero WHERE full_ename IS NULL; 
SELECT colour.colour FROM superhero  JOIN colour ON superhero.eye_colour_id = colour.id  WHERE superhero.id = 75; 
  SELECT sp.power_name  FROM superpower sp  JOIN hero_power hp ON sp.id = hp.power_id  JOIN superhero sh ON hp.hero_id = sh.id  WHERE sh.superhero_name = 'Deathlok';
  To find the average weight of all female superheroes, we need to calculate the average of `weight_kg` in the `superhero` table where `gender_id` is 2 (corresponding to Female).  SELECT AVG(weight_kg) FROM superhero WHERE gender_id = 2;
SELECT sp.power_name  FROM superpower sp  JOIN hero_power hp ON sp.id = hp.power_id  JOIN superhero s ON hp.hero_id = s.id  JOIN gender g ON s.gender_id = g.id  WHERE g.gender = 'Male'; 
  SELECT superhero.superhero_name FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE race.race = 'Alien';
SELECT superhero_name  FROM superhero  WHERE height_cm BETWEEN 170 AND 190  AND eye_Colour_id = (SELECT id FROM colour WHERE colour = 'No Colour'); 
  SELECT power_name FROM superpower sp JOIN hero_power hp ON sp.id = hp.power_id WHERE hp.hero_id = 56;
SELECT s.full_name FROM superhero s JOIN race r ON s.race_id = r.id WHERE r.race = 'Demi-God'; 
SELECT COUNT(*) FROM superhero WHERE alignment_id = 2; 
  SELECT r.race FROM race r INNER JOIN superhero s ON r.id = s.race_id WHERE s.weight_kg = 169;
  SELECT colour.colour  FROM superhero  JOIN colour ON superhero.hair_colour_id = colour.id  JOIN race ON superhero.race_id = race.id  WHERE superhero.height_cm = 185 AND race.race = 'human';
  SELECT c.colour FROM superhero s JOIN colour c ON s.eye_colour_id = c.id WHERE s.weight_kg = (SELECT MAX(s.weight_kg) FROM superhero);
SELECT    (COUNT(CASE WHEN publisher_id = 13 THEN 1 END) * 100.0 / (SELECT COUNT(*) FROM superhero WHERE height_cm BETWEEN 150 AND 180)) AS percentage FROM    superhero WHERE    height_cm BETWEEN 150 AND 180; 
SELECT s.superhero_name FROM superhero s JOIN gender g ON s.gender_id = g.id WHERE g.name = 'Male' AND s.weight_kg > (SELECT 0.79 * AVG(s2.weight_kg) FROM superhero s2); 
SELECT sp.power_name FROM superpower sp JOIN hero_power hp ON sp.id = hp.power_id GROUP BY sp.id HAVING COUNT(*) = (     SELECT MAX(sub.cnt)     FROM (         SELECT power_id, COUNT(*) as cnt         FROM hero_power         GROUP BY power_id     ) sub ); 
  SELECT `attribute_value` FROM `hero_attribute` WHERE `hero_id` = (SELECT `id` FROM `superhero` WHERE `superhero_name` = 'Abomination');
  SELECT superpower.power_name FROM superpower INNER JOIN hero_power ON superpower.id = hero_power.power_id WHERE hero_power.hero_id = 1;
SELECT COUNT(DISTINCT hp.hero_id) FROM superpower sp  JOIN hero_power hp ON sp.id = hp.power_id  WHERE sp.power_name = 'stealth'; 
SELECT s.full_name FROM superhero s  JOIN hero_attribute ha ON s.id = ha.hero_id  WHERE ha.attribute_id = 2  ORDER BY ha.attribute_value DESC  LIMIT 1; 
SELECT      (SUM(CASE WHEN skin_colour_id = 1 THEN 1 ELSE 0 END) * 1.0) / COUNT(*) AS average FROM superhero; 
 SELECT COUNT(*) FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  WHERE p.publisher_name = 'Dark Horse Comics'; 
  SELECT s.superhero_ename  FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  JOIN hero_attribute ha ON s.id = ha.hero_id  WHERE p.publisher_ename = 'Dark Horse Comics' AND ha.attribute_id = (SELECT id FROM attribute WHERE attribute_ename = 'Durability')  GROUP BY s.superhero_ename  ORDER BY MAX(ha.attribute_value) DESC  LIMIT 1;
SELECT c.colour FROM superhero s INNER JOIN colour c ON s.eye_colour_id = c.id WHERE s.full_name = 'Abraham Sapien'; 
SELECT superhero.superhero_name  FROM superhero  JOIN hero_power ON superhero.id = hero_power.hero_id  JOIN superpower ON hero_power.power_id = superpower.id  WHERE superpower.power_name = 'Flight'; 
SELECT DISTINCT c.customer_id FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE o.amount > 100 AND c.state = 'California'; 
  SELECT superhero.superhero_name, publisher.publisher_name FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.eye_colour_id = superhero.hair_colour_id AND superhero.hair_colour_id = superhero.skin_colour_id;
SELECT r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.superhero_name = 'A-Bomb'; 
SELECT      (SUM(CASE WHEN c.colour = 'Blue' THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) * 100 AS percentage FROM superhero s JOIN gender g ON s.gender_id = g.id JOIN colour c ON s.skin_colour_id = c.id WHERE g.gender = 'Female'; 
  SELECT superhero.superhero_ename, race.race FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE superhero.full_ame = 'Charles Chandler';
SELECT s.superhero_name AS "Superhero Name", g.gender AS Gender  FROM superhero s  JOIN gender g ON s.gender_id = g.id  WHERE s.superhero_name = 'Agent 13'; 
  SELECT s.superhero_name FROM superhero s INNER JOIN hero_ower hp ON s.id = hp.hero_id INNER JOIN superpower p ON hp.power_id = p.id WHERE p.power_name = 'Adaptation';
  SELECT COUNT(DISTINCT hp.power_id) AS num_powers FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id WHERE s.superhero_name = 'Amazo';
  SELECT sp.power_name FROM superpower sp JOIN hero_power hp ON sp.id = hp.power_id JOIN superhero sh ON hp.hero_id = sh.id WHERE sh.full_name = 'Hunter Zolomon';
  SELECT `superhero`.`height__cm` FROM `superhero` JOIN `colour` ON `superhero`.`eye_colour_id` = `colour`.`id` WHERE `colour`.`colour` = 'Amber';
  SELECT superhero.superhero_name  FROM superhero  JOIN colour ON superhero.eye_colour_id = colour.id AND colour.colour = 'Black'  JOIN colour AS c2 ON superhero.hair_colour_id = c2.id AND c2.colour = 'Black';
  SELECT c2.colour AS EyeColour FROM superhero s JOIN colour c1 ON s.skin_colour_id = c1.id JOIN colour c2 ON s.eye_colour_id = c2.id WHERE c1.colour = 'Gold';
SELECT superhero.full_ename  FROM superhero  INNER JOIN race ON superhero.race_id = race.id  WHERE race.race = 'Vampire'; 
SELECT superhero.superhero_name  FROM superhero  JOIN alignment ON superhero.alignment_id = alignment.id  WHERE alignment.alignment = 'Neutral'; 
SELECT COUNT(*) FROM hero_attribute  WHERE attribute_id = 2 AND attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute WHERE attribute_id = 2); 
  SELECT r.race, a.alignment FROM superhero s JOIN race r ON s.race_id = r.id JOIN alignment a ON s.alignment_id = a.id WHERE s.superhero_name = 'Cameron Hicks';
SELECT      (COUNT(s.id) * 100.0 / (SELECT COUNT(*) FROM superhero WHERE publisher_id = p.id)) AS percentage FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name = 'Marvel Comics' AND s.gender_id IN (SELECT id FROM gender WHERE gender = 'Female'); 
  SELECT AVG(sh.weight_kg)  FROM superhero sh  JOIN race r ON sh.race_id = r.id  WHERE r.race = 'Alien';
SELECT      (SELECT SUM(weight_kg) FROM superhero WHERE full_name = 'Emil Blonsky') -      (SELECT SUM(weight_kg) FROM superhero WHERE full_name = 'Charles Chandler') AS difference; 
  SELECT SUM(height_cm) / COUNT(*) AS average_height FROM superhero;
SELECT s.superhero_name, spower.power_name FROM superhero s LEFT JOIN hero_power hp ON s.id = hp.hero_id LEFT JOIN superpower spower ON hp.power_id = spower.id WHERE s.superhero_name = 'Abomination'; 
SELECT COUNT(*) FROM superhero WHERE race_id=21 AND gender_id=1; 
  SELECT s.superhero_name FROM superhero s JOIN hero_attribute ha ON s.id = ha.hero_id WHERE ha.attribute_id = 3 AND ha.attribute_value = (     SELECT MAX(ha2.attribute_value)     FROM hero_attribute ha2     WHERE ha2.attribute_id = 3 )
  SELECT COUNT(*) FROM superhero WHERE alignment_id = 3;
SELECT a.attribute_name, ha.attribute_value  FROM superhero s  JOIN hero_attribute ha ON s.id = ha.hero_id  JOIN attribute a ON ha.attribute_id = a.id  WHERE s.superhero_name = '3- D Man'; 
  SELECT superhero.superhero_name FROM superhero JOIN colour AS e ON superhero.eye_colour_id = e.id AND e.colour = 'Blue' JOIN colour AS h ON superhero.hair_colour_id = h.id AND h.colour = 'Brown';
  SELECT s.superhero_name, p.publisher_name FROM superhero s LEFT JOIN publisher p ON s.publisher_id = p.id WHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');
SELECT COUNT(s.id) FROM superhero s LEFT JOIN publisher p ON s.publisher_id = p.id WHERE p.id IS NULL; 
  SELECT (COUNT(CASE WHEN eye_ colour_id = 7 THEN id END) / COUNT(*)) * 100 AS percentage FROM superhero;
SELECT      SUM(CASE WHEN gender_id = 2 THEN 1 ELSE 0 END) AS male_superheroes,     SUM(CASE WHEN gender_id = 1 THEN 1 ELSE 0 END) AS female_superheroes,     (SUM(CASE WHEN gender_id = 2 THEN 1 ELSE 0 END) / SUM(CASE WHEN gender_id = 1 THEN 1 ELSE 0 END)) AS ratio FROM superhero; 
SELECT superhero_name  FROM superhero  WHERE height_om = (SELECT MAX(height_om) FROM superhero); 
  SELECT `id` FROM `superpower` WHERE `power_name` = 'cryokinesis';
  SELECT superhero_ename FROM superhero WHERE id = 294;
  SELECT full_name FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL;
  SELECT colour.colour FROM colour INNER JOIN superhero ON colour.id = superhero.eye_colour_id WHERE superhero.full_name = 'Karen Beecher- Duncan';
  SELECT sp.power_name FROM superpower sp INNER JOIN hero_power hp ON sp.id = hp.power_id INNER JOIN superhero sh ON hp.hero_id = sh.id WHERE sh.full_ename = 'Helen Parr';
SELECT r.race FROM superhero s INNER JOIN race r ON s.race_id = r.id WHERE s.height_cm = 188 AND s.weight_kg = 108; 
  SELECT publisher.publisher_name FROM publisher JOIN superhero ON publisher.id = superhero.publisher_id WHERE superhero.id = 38;
  SELECT r.race FROM hero_attribute ha JOIN superhero s ON ha.hero_id = s.id JOIN race r ON s.race_id = r.id WHERE ha.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute) ORDER BY ha.attribute_value DESC LIMIT 1;
  SELECT s.superhero_name AS alignment, sp.power_1ame AS superpower FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE s.superhero_name LIKE 'Atom%';  This query selects the superhero's name as alignment and their power names from the superpower table. It joins the superhero, hero_power, and superpower tables to retrieve the necessary information. The WHERE clause filters for superheroes whose names start with "Atom", accommodating different versions like Atom IV.
SELECT superhero.superhero_name FROM superhero  JOIN colour ON superhero.eye_colour_id = colour.id  WHERE colour.colour = 'Blue'; 
  SELECT AVG(ha.attribute_value)  FROM superhero s  JOIN hero_attribute ha ON s.id = ha.hero_id  WHERE s.alignment_id = 3;
  SELECT colour.colour  FROM hero_attribute  JOIN superhero ON hero_attribute.hero_id = superhero.id  JOIN colour ON superhero.skin_colour_id = colour.id  WHERE hero_attribute.attribute_value = 100;
SELECT COUNT(*) FROM superhero WHERE gender_id = 2 AND alignment_id = 1; 
  SELECT `superhero`.`superhero_name` FROM `superhero` JOIN `hero_attribute` ON `superhero`.`id` = `hero_attribute`.`hero_id` WHERE `attribute_value` BETWEEN 75 AND 80;
SELECT race.race FROM superhero  JOIN colour ON superhero.hair_colour_id = colour.id  JOIN gender ON superhero.gender_id = gender.id  JOIN race ON superhero.race_id = race.id  WHERE colour.colour = 'blue' AND gender.gender = 'Male'; 
SELECT      (COUNT(CASE WHEN g.id = 2 THEN s.id END) / COUNT(s.id)) * 100.0 AS percentage_female_bad_superheroes  FROM      superhero s JOIN      alignment a ON s.alignment_id = a.id JOIN      gender g ON s.gender_id = g.id WHERE      a.id = 2; 
SELECT      (COUNT(CASE WHEN superhero.eye_colour_id = 7 THEN 1 END) - COUNT(CASE WHEN superhero.eye_colour_id = 1 THEN 1 END)) AS difference FROM      superhero WHERE      superhero.weight_kg = 0 OR superhero.weight_kg IS NULL; 
SELECT COALESCE(ha.attribute_value, 0) AS strength  FROM superhero s  LEFT JOIN hero_attribute ha ON s.id = ha.hero_id  LEFT JOIN attribute a ON a.id = ha.attribute_id  WHERE s.superhero_name = 'Hulk' AND a.attribute_name = 'Strength'; 
SELECT sp.power_name AS superpowers  FROM superhero h  JOIN hero_power hp ON h.id = hp.hero_id  JOIN superpower sp ON hp.power_id = sp.id  WHERE h.superhero_name = 'Ajax'; 
SELECT COUNT(*) FROM superhero  JOIN colour ON superhero.skin_colour_id = colour.id  JOIN alignment ON superhero.alignment_id = alignment.id  WHERE colour.colour = 'Green' AND alignment.alignment = 'Bad'; 
SELECT COUNT(*)  FROM superhero  JOIN gender ON superhero.gender_id = gender.id  JOIN publisher ON superhero.publisher_id = publisher.id  WHERE gender.gender = 'Female' AND publisher.publisher_name = 'Marvel Comics'; 
SELECT superhero.superhero_name  FROM superhero  JOIN hero_power ON superhero.id = hero_power.hero_id  JOIN superpower ON hero_power.power_id = superpower.id  WHERE superpower.power_name = 'Wind Control'  ORDER BY superhero_name ASC; 
  SELECT g.gender FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id JOIN gender g ON s.gender_id = g.id WHERE sp.power_name = 'Phoenix Force';
  SELECT s.superhero_name, MAX(s.weight_kg)  FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  WHERE p.publisher_name = 'DC Comics'  GROUP BY s.superhero_name;
  SELECT AVG(height_ cm) FROM superhero s JOIN publisher p ON s.publisher_id = p.id JOIN race r ON s.race_id = r.id WHERE p.publisher_name = 'Dark Horse Comics' AND r.race <> 'Human';
  SELECT COUNT(DISTINCT ha.hero_id) FROM hero_attribute ha JOIN attribute a ON ha.attribute_id = a.id WHERE a.attribute_name = 'Speed' AND ha.attribute_value = 100;
  SELECT      (COUNT(CASE WHEN p.publisher_ame = 'DC Comics' THEN 1 END) - COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END)) AS difference FROM      superhero s JOIN      publisher p ON s.publisher_id = p.id WHERE      p.publisher_name IN ('DC Comics', 'Marvel Comics');
  SELECT attribute_name FROM attribute JOIN hero_attribute ON attribute.id = hero_attribute.attribute_id JOIN superhero ON hero_attribute.hero_id = superhero.id WHERE superhero.superhero_ame = 'Black Panther' ORDER BY attribute_value ASC LIMIT 1;
SELECT c.colour FROM colour c  JOIN superhero s ON c.id = s.eye_colour_id  WHERE s.superhero_name = 'Abomination'; 
  SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_ cm) FROM superhero);
  SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';
SELECT      (SUM(CASE WHEN g.gender = 'Female' THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) * 100 AS female_percentage FROM      superhero s JOIN      gender g ON s.gender_id = g.id WHERE      s.publisher_id = 5; 
  SELECT    (COUNT(CASE WHEN a.alignment = 'Good' THEN s.id END) / COUNT(s.id)) * 100.0 AS good_percentage  FROM superhero s  JOIN publisher p ON s.publisher_id = p.id  WHERE p.publisher_name = 'Marvel Comics';
SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'; 
SELECT `hero_id` FROM `hero_attribute` WHERE `attribute_value` = (SELECT MIN(`attribute_value`) FROM `hero_attribute`); 
  SELECT full_name FROM superhero WHERE superhero_ name = 'Alien';
SELECT superhero.full_name  FROM superhero  JOIN colour ON superhero.eye_colour_id = colour.id  WHERE superhero.weight_kg < 100 AND colour.colour = 'Brown'; 
SELECT ha.attribute_value  FROM superhero s  JOIN hero_attribute ha ON s.id = ha.hero_id  WHERE s.superhero_name = 'Aquababy'; 
SELECT s.weight_kg, r.race FROM superhero s INNER JOIN race r ON s.race_id = r.id WHERE s.id = 40; 
  SELECT AVG(height_cm) AS AverageHeight FROM superhero WHERE alignment_id = 3;
  SELECT hero_id FROM hero_power HP JOIN superpower SP ON HP.power_id = SP.id WHERE SP.power_name = 'Intelligence';
SELECT colour FROM colour  JOIN superhero ON colour.id = superhero.eye_ colour_id  WHERE superhero.superhero_name = 'Blackwulf'; 
SELECT sp.power_name FROM superhero sh JOIN hero_power hp ON sh.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE sh.height_cm > (SELECT 0.8 * AVG(sh2.height_cm) FROM superhero sh2); 
SELECT driverRef  FROM qualifying  WHERE raceId = 20 AND q1 IN (     SELECT MAX(q1)      FROM qualifying      WHERE raceId = 20 ) LIMIT 5; 
SELECT d.surname FROM drivers d  JOIN qualifying q ON d.driverId = q.driverId  WHERE q.raceId = 19  ORDER BY q.q2 ASC  LIMIT 1; 
SELECT DISTINCT year FROM races  JOIN circuits ON races.circuitId = circuits.circuitId  WHERE circuits.location = 'Shanghai'; 
SELECT r.url  FROM races r  INNER JOIN circuits c ON r.circuitId = c.circuitId  WHERE c.name = 'Circuit de Barcelona-Catalunya'; 
  SELECT `races`.`name` FROM `races` JOIN `circuits` ON `races`.`circuitId` = `circuits`.`circuitId` WHERE `circuits`.`country` = 'Germany';
  SELECT cs.position FROM constructors c JOIN constructorStandings cs ON c.constructorId = cs.constructorId WHERE c.name = 'Renault';
  SELECT COUNT(*) FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2010 AND c.country NOT IN ('Malaysia', 'Bahrain', 'Spain', 'Turkey', 'Monaco');
  SELECT races.name FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.country = 'Spain';
SELECT c.lat, c.lng  FROM races r  JOIN circuits c ON r.circuitId = c.circuitId  WHERE r.name = 'Australian Grand Prix'; 
  SELECT `races`.`url` FROM `circuits`  INNER JOIN `races` ON `circuits`.`circuitId` = `races`.`circuitId`  WHERE `circuits`.`name` = 'Sepang International Circuit';
SELECT COUNT(*) AS NumberOfEvents FROM races WHERE circuitId = 2; 
SELECT c.lat, c.lng  FROM circuits c  JOIN races r ON c.circuitId = r.circuitId  WHERE r.name = 'Abu Dhabi Grand Prix'; 
  SELECT nationality FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId WHERE cr.points = 1 AND cr.raceId = 24;
  SELECT q1 FROM qualifying JOIN drivers ON qualifying.driverId = drivers.driverId WHERE raceId = 354 AND forename = 'Bruno' AND surname = 'Senna';
SELECT d.nationality  FROM drivers d  JOIN qualifying q ON d.driverId = q.driverId  WHERE q.raceId = 355 AND q.q2 = '0:01:40'; 
SELECT d.number FROM qualifying q JOIN drivers d ON q.driverId = d.driverId WHERE q.raceId = 903 AND q.q3 LIKE '1:54%'; 
SELECT COUNT(res.driverId) FROM races r  JOIN results res ON r.raceId = res.raceId  WHERE r.name = 'Bahrain Grand Prix' AND r.year = 2007 AND res.time IS NULL; 
SELECT s.url FROM seasons s JOIN races r ON s.year = r.year WHERE r.raceId = 901; 
SELECT COUNT(DISTINCT r.driverId) AS num_drivers_finished FROM results r JOIN races ra ON r.raceId = ra.raceId WHERE ra.date = '2015-11-29' AND r.time IS NOT NULL; 
  SELECT `drivers`.`forename`, `drivers`.`surname`, MIN(`drivers`.`dob`) as oldest_dob FROM `drivers` INNER JOIN `results` ON `drivers`.`driverId` = `results`.`driverId` WHERE `results`.`raceId` = 592 AND `results`.`time` IS NOT NULL GROUP BY `results`.`raceId` LIMIT 1
  SELECT `drivers`.`url` FROM `drivers` JOIN `lapTimes` ON `drivers`.`driverId` = `lapTimes`.`driverId` WHERE `raceId` = 161 AND `time` LIKE '0:01:27%';
  WITH max_speed AS (     SELECT MAX(fastestLapSpeed) AS max_sp     FROM results     WHERE raceId = 933 ) SELECT d.nationality FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE r.raceId = 933 AND r.fastestLapSpeed = (SELECT max_sp FROM max_speed);
  SELECT lat, lng FROM circuits WHERE circuitId = (SELECT circuitId FROM races WHERE name = 'Malaysian Grand Prix');
SELECT c.url  FROM constructors c  JOIN constructorResults cr ON c.constructorId = cr.constructorId  WHERE cr.raceId = 9 AND cr.points = (     SELECT MAX(points)      FROM constructorResults      WHERE raceId = 9 ); 
  SELECT q1  FROM drivers d  JOIN qualifying q ON d.driverId = q.driverId  WHERE d.forename LIKE '%Lucas%' AND d.surname LIKE '%di%Grassi%' AND q.raceId = 345;
  SELECT drivers.nationality FROM drivers JOIN qualifying ON drivers.driverId = qualifying.driverId WHERE qualifying.raceId = 347 AND qualifying.q2 = '0:01:15';
SELECT `code` FROM `drivers`  JOIN `qualifying` ON `drivers`.`driverId` = `qualifying`.`driverId`  WHERE `qualifying`.`raceId` = 45 AND `qualifying`.`q3` LIKE '1:33%'; 
  SELECT `drivers`.`forename`, `drivers`.`surname`, `results`.`time`  FROM `drivers` JOIN `results` ON `drivers`.`driverId` = `results`.`driverId`  WHERE `results`.`raceId` = 743 AND (`drivers`.`forename` LIKE '%Bruce%' OR `drivers`.`surname` LIKE '%McLaren%');
  SELECT d.forename, d.surname  FROM drivers AS d  JOIN results AS r ON d.driverId = r.driverId  JOIN races AS ra ON r.raceId = ra.raceId  WHERE ra.name = 'San Marino Grand Prix'  AND ra.year = 2006  AND r.position = 2;
  SELECT url FROM seasons WHERE year = (SELECT year FROM races WHERE raceId=901);
SELECT COUNT(*) AS NumberOfDrivers FROM results WHERE raceId = (     SELECT raceId     FROM races     WHERE date = '2015/11/29' ) AND statusId != 1; 
SELECT d.driverId, d.forename, d.surname, d.dob FROM drivers d JOIN results r ON d.driverId = r.driverId WHERE r.raceId = 872 AND r.time IS NOT NULL ORDER BY d.dob DESC LIMIT 1; 
SELECT d.forename, d.surname  FROM lapTimes l  JOIN drivers d ON l.driverId = d.driverId  WHERE l.raceId = 348  ORDER BY l.time ASC  LIMIT 1; 
  SELECT d.nationality FROM drivers d WHERE d.driverId = (     SELECT r.driverId      FROM results r     GROUP BY r.driverId     ORDER BY MAX(r.fastestLapSpeed) DESC      LIMIT 1 );
  SELECT ((r1.fastestLapSpeed - r2.fastestLapSpeed) / r1.fastestLapSpeed * 100) AS percentage FROM results r1 JOIN drivers d ON r1.driverId = d.driverId WHERE d.forename = 'Paul' AND d.surname = 'di Resta' AND r1.raceId = 853 AND EXISTS (     SELECT 1 FROM results r2 WHERE r2.driverId = r1.driverId AND r2.raceId = 854 );
  SELECT (COUNT(CASE WHEN r.time IS NOT NULL THEN 1 END) / COUNT(r.driverId)) * 100 AS completion_rate FROM results r JOIN races ra ON r.raceId = ra.raceId WHERE ra.date = '1983-07-16';
SELECT MIN(year) FROM races WHERE name = 'Singapore Grand Prix'; 
SELECT (SELECT COUNT(*) FROM races WHERE year = 2005) AS total_races,        name  FROM races  WHERE year = 2005  ORDER BY name DESC; 
SELECT raceName FROM races WHERE YEAR(date) = YEAR((SELECT MIN(date) FROM races)) AND MONTH(date) = MONTH((SELECT MIN(date) FROM races)); 
  SELECT name, date FROM races WHERE year = 1999 AND round = (SELECT MAX(round) FROM races WHERE year = 1999);
  WITH YearMaxRounds AS (     SELECT          year,         MAX(round) AS max_round     FROM          races     GROUP BY          year ) SELECT      year FROM      YearMaxRounds WHERE      max_round = (SELECT MAX(max_round) FROM YearMaxRounds);
  SELECT name FROM races WHERE year = 2017 AND NOT EXISTS (SELECT name FROM races WHERE year = 2000 AND races.name = races.name);
  SELECT c.country, c.name AS circuit_name, c.location  FROM circuits c  JOIN races r ON c.circuitId = r.circuitId  WHERE c.country IN ('Spain', 'Monaco')  ORDER BY r.year ASC  LIMIT 1;
  SELECT MAX(year) FROM races WHERE name = 'British Grand Prix';  The answer is 2009-04-26.
SELECT COUNT(*) FROM races AS r JOIN circuits AS c ON r.circuitId = c.circuitId WHERE c.name = 'Silverstone Circuit' AND r.name = 'British Grand Prix'; 
SELECT drivers.forename, drivers.surname  FROM driverStandings  JOIN drivers ON driverStandings.driverId = drivers.driverId  WHERE driverStandings.raceId IN (     SELECT races.raceId      FROM races      WHERE races.year = 2010 AND races.name = 'Singapore Grand Prix' ) ORDER BY driverStandings.position; 
  SELECT d.forename, d.surname, ds.points FROM drivers d JOIN (     SELECT driverId, MAX(points) AS points     FROM driverStandings     GROUP BY driverId ) ds ON d.driverId = ds.driverId ORDER BY ds.points DESC LIMIT 1
  The database schema and data do not contain information for the 2017 Chinese Grand Prix. The races table only includes entries from 2009. Therefore, it's impossible to generate a meaningful query based on the provided question.  If you have additional data or corrections, please provide them so I can assist further.
  SELECT d.forename, d.surname, r.name FROM lapTimes lt JOIN drivers d ON lt.driverId = d.driverId JOIN races r ON lt.raceId = r.raceId WHERE lt.milliseconds = (SELECT MIN(mill) FROM (SELECT milliseconds mill FROM lapTimes) AS temp);
SELECT AVG(laptime) AS average_lap_time  FROM laps  JOIN races ON laps.raceId = races.raceId  JOIN drivers ON laps.driverId = drivers.driverId  WHERE races.name = 'Malaysian Grand Prix'  AND drivers.forename = 'Lewis'  AND drivers.surname = 'Hamilton'; 
  SELECT      (COUNT(CASE WHEN ds.position > 1 THEN ds.raceId END) / COUNT(ds.raceId)) * 100 AS percentage FROM      drivers d JOIN      driverStandings ds ON d.driverId = ds.driverId JOIN      races r ON ds.raceId = r.raceId WHERE      d.surname = 'Hamilton' AND r.year >= 2010;
SELECT d.forename, d.surname, d.nationality, MAX(r.points) AS max_points, COUNT(r.resultId) AS total_wins FROM drivers d JOIN results r ON d.driverId = r.driverId WHERE r.position = 1 GROUP BY d.driverId ORDER BY total_wins DESC, max_points DESC LIMIT 1; 
SELECT forename, surname, (YEAR(CURRENT_TIMESTAMP) - YEAR(dob)) AS age FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1; 
SELECT c.name AS CircuitName  FROM circuits c  JOIN races r ON c.circuitId = r.circuitId  WHERE YEAR(r.date) BETWEEN 1990 AND 2000  GROUP BY c.name  HAVING COUNT(r.raceId) = 4; 
  SELECT c.name AS CircuitName, c.location AS CircuitLocation, r.name AS RaceName FROM circuits c JOIN races r ON c.circuitId = r.circuitId WHERE c.country = 'USA' AND r.year = 2006;
  SELECT races.name AS race_name, circuits.name AS circuit_name, circuits.location   FROM races   INNER JOIN circuits ON races.circuitId = circuits.circuitId   WHERE YEAR(races.date) = 2005 AND MONTH(races.date) = 9;
SELECT r.raceId, r.year, r.name  FROM results res  JOIN drivers dr ON res.driverId = dr.driverId  JOIN races r ON res.raceId = r.raceId  WHERE dr.forename = 'Alex' AND dr.surname = 'Yoong' AND res.grid < 20; 
SELECT COUNT(ds.wins) AS total_wins  FROM drivers d  JOIN driverStandings ds ON d.driverId = ds.driverId  WHERE d.forename = 'Michael' AND d.surname = 'Schumacher'  AND ds.wins > 0; 
SELECT r.name AS RaceName, r.year AS RaceYear FROM lapTimes lt JOIN drivers d ON lt.driverId = d.driverId JOIN races r ON lt.raceId = r.raceId WHERE d.forename = 'Michael' AND d.surname = 'Schumacher' AND lt.milliseconds = (     SELECT MIN(lt2.milliseconds)     FROM lapTimes lt2     JOIN drivers d2 ON lt2.driverId = d2.driverId     WHERE d2.forename = 'Michael' AND d2.surname = 'Schumacher' ); 
SELECT AVG(points) AS average_points  FROM driverStandings  WHERE raceId IN (SELECT raceId FROM races WHERE year = 2000)  AND driverId IN (SELECT driverId FROM drivers WHERE forename = 'Eddie' AND surname = 'Irvine'); 
SELECT races.name AS first_race_name, driverStandings.points  FROM driverStandings  JOIN drivers ON driverStandings.driverId = drivers.driverId  JOIN races ON driverStandings.raceId = races.raceId  WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'  AND races.year = (SELECT MIN(races.year) FROM driverStandings  JOIN drivers ON driverStandings.driverId = drivers.driverId  JOIN races ON driverStandings.raceId = races.raceId  WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'); 
SELECT races.name AS race_name, circuits.country, races.date  FROM races  JOIN circuits ON races.circuitId = circuits.circuitId  WHERE races.year = 2017  ORDER BY races.date; 
WITH RaceLaps AS (     SELECT          raceId,         COUNT(lap) AS total_laps     FROM          lapTimes     GROUP BY          raceId ) SELECT      r.name AS race_name,     r.year AS year,     c.location AS circuit_location FROM      races r JOIN      RaceLaps rl ON r.raceId = rl.raceId JOIN      circuits c ON r.circuitId = c.circuitId WHERE      rl.total_laps = (SELECT MAX(total_laps) FROM RaceLaps); 
  SELECT (COUNT(c.country = 'Germany' OR NULL) / COUNT(*)) * 100 AS percentage FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.name = 'European Grand Prix';
  SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';
SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1; 
  SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';
SELECT country  FROM circuits  WHERE alt = (SELECT MAX(alt) FROM circuits); 
  SELECT COUNT(*) FROM drivers WHERE code IS NULL;
SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers); 
  SELECT surname FROM drivers WHERE nationality = 'Italian';
SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'; 
SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'; 
SELECT circuits.name FROM races  JOIN circuits ON races.circuitId = circuits.circuitId  WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009; 
SELECT year FROM races  JOIN circuits ON races.circuitId = circuits.circuitId  WHERE circuits.name = 'Silverstone Circuit'; 
  SELECT * FROM circuits AS c  JOIN races AS r ON c.circuitId = r.circuitId  WHERE c.name = 'Silverstone';
  SELECT `races`.`time`  FROM `circuits`  JOIN `races` ON `circuits`.`circuitId` = `races`.`circuitId`  WHERE `races`.`year` = 2010 AND `circuits`.`name` = 'Abu Dhabi Circuit';
  SELECT COUNT(*) FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.country = 'Italy';
SELECT races.date  FROM races  JOIN circuits ON races.circuitId = circuits.circuitId  WHERE circuits.name = 'Circuit de Barcelona- Catalunya'; 
  SELECT url FROM circuits WHERE circuitId = (SELECT circuitId FROM races WHERE year = 2009 AND name = 'Spanish Grand Prix');
SELECT MIN(results.fastestLapTime)  FROM results  WHERE results.driverId = (     SELECT drivers.driverId      FROM drivers      WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' ); 
SELECT d.forename, d.surname  FROM drivers d  JOIN results r ON d.driverId = r.driverId  WHERE r.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results); 
SELECT dr.driverRef  FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers dr ON res.driverId = dr.driverId WHERE r.name = 'Canadian Grand Prix' AND r.year = 2007 AND res.position = 1; 
  SELECT `races`.`name` FROM `races` INNER JOIN `results` ON `races`.`raceId` = `results`.`raceId` WHERE `results`.`driverId` = 1;
  SELECT races.name FROM results JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND results.rank = (     SELECT MIN(rank)     FROM results     JOIN drivers ON results.driverId = drivers.driverId     WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' );
SELECT MAX(results.fastestLapSpeed)  FROM results  JOIN races ON results.raceId = races.raceId  WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009; 
SELECT DISTINCT year FROM races r JOIN results res ON r.raceId = res.raceId WHERE res.driverId = 1; 
SELECT res.positionOrder FROM results res JOIN races rac ON res.raceId = rac.raceId JOIN drivers dri ON res.driverId = dri.driverId WHERE dri.forename = 'Lewis' AND dri.surname = 'Hamilton' AND rac.name = 'Chinese Grand Prix' AND rac.year = 2008; 
SELECT d.forename, d.surname  FROM races r  JOIN results res ON r.raceId = res.raceId  JOIN drivers d ON res.driverId = d.driverId  WHERE r.year = 1989 AND r.name LIKE '%Australian Grand Prix%' AND res.grid = 4; 
  SELECT COUNT(results.driverId) AS finishedDrivers FROM races INNER JOIN results ON races.raceId = results.raceId WHERE races.year = 2008 AND races.name = 'Australian Grand Prix' AND results.time IS NOT NULL;
SELECT MAX(r.fastestLap) AS FastestLap  FROM results r  JOIN races ra ON r.raceId = ra.raceId  WHERE ra.name = 'Australian Grand Prix' AND ra.year = 2008; 
SELECT r.time  FROM results AS r  INNER JOIN races AS ra ON r.raceId = ra.raceId  WHERE ra.name = 'Chinese Grand Prix' AND ra.year = 2008 AND r.position = 2; 
  SELECT d.forename, d.surname, d.url FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE r.year = 2008 AND r.name = 'Australian Grand Prix' AND res.time REGEXP '^\\d{1,2}:\\d{2}:\\d{2}\\.\\d{3}$';
SELECT COUNT(DISTINCT d.driverId) AS british_drivers_count FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE r.year = 2008  AND r.name LIKE '%Australian%' AND d.nationality = 'British'; 
SELECT COUNT(DISTINCT r.driverId) AS NumberOfDrivers FROM results r WHERE r.raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix' AND year = 2008) AND r.time IS NOT NULL AND (     SELECT COUNT(*)      FROM results r2      WHERE r2.driverId = r.driverId      AND r2.time IS NOT NULL ) > 1; 
SELECT SUM(points) FROM results WHERE driverId = 1; 
SELECT AVG(     CAST(SUBSTRING_INDEX(fastestLapTime, ':', 1) AS UNSIGNED) * 60 +     CAST(SUBSTRING_INDEX(SUBSTRING_INDEX(fastestLapTime, ':', -1), '.', 1) AS UNSIGNED) +     CAST(SUBSTRING_INDEX(fastestLapTime, '.', -1) AS UNSIGNED) / 1000 ) AS average_fastest_lap_time_seconds FROM drivers d JOIN results r ON d.driverId = r.driverId WHERE forename = 'Lewis' AND surname = 'Hamilton'; 
SELECT      (COUNT(results.time) / COUNT(*)) AS completion_rate FROM      races  JOIN      results ON races.raceId = results.raceId WHERE      races.year = 2008 AND races.name = 'Australian Grand Prix'; 
python import pandas as pd  def convert_time(time_str):     if time_str.startswith('+'):         # It's a delay, not an absolute time         return float(time_str[1:])     else:         # Split into hours, minutes, seconds and milliseconds         parts = time_str.split(':')         hh = int(parts[0])         mm = int(parts[1])         ss_ms = parts[2].split('.')         ss = int(ss_ms[0])         ms = int(ss_ms[1]) if len(ss_ms) > 1 else 0         total_seconds = hh * 3600 + mm * 60 + ss + (ms / 1000)         return total_seconds  # Sample data for demonstration data = {     'race_id': [1, 1, 1],     'position_order': ['1:34:50.616', '+5.478', '+12.34'],     # Assuming other necessary columns are present but not used here }  df = pd.DataFrame(data)  # Step 1: Identify the target race (assuming we have a way to select it) target_race_id = 1  # Step 2: Extract relevant rows for this race race_results = df[df['race_id'] == target_race_id]  # Step 3: Find champion's time and collect delays champion_time_str = None delays = []  for pos_order in race_results['position_order']:     if not pos_order.startswith('+'):         champion_time_str = pos_order     else:         delay = convert_time(pos_order)         delays.append(delay)  # Convert champion's time to seconds T0 = convert_time(champion_time_str) if champion_time_str else None  if T0 is None:     raise ValueError("No champion found with absolute time.")  # Step 4: Find max delay max_delay = max(delays) if delays else 0  # Calculate last driver's time T_last = T0 + max_delay  # Step 5: Compute percentage faster percentage_faster = (max_delay / T0) * 100  print(f"The champion is {percentage_faster:.2f}% faster than the last driver.") 
SELECT COUNT(*) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'; 
SELECT lat, lng FROM circuits WHERE country = 'USA'; 
  SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND YEAR(dob) > 1980;
SELECT MAX(r.points) AS max_points  FROM constructors c  JOIN results r ON c.constructorId = r.constructorId  WHERE c.nationality = 'British'; 
SELECT constructors.name FROM constructors  JOIN constructor_standings ON constructors.constructorId = constructor_standings.constructorId  WHERE constructor_standings.points = (SELECT MAX(points) FROM constructor_standings); 
  SELECT DISTINCT c.name   FROM constructors c   JOIN constructorStandings cs ON c.constructorId = cs.constructorId   WHERE cs.raceId = 291 AND cs.points = 0;
  SELECT COUNT(*) FROM constructors c WHERE c.nationality = 'Japanese' AND (SELECT COUNT(cs.raceId) FROM constructorStandings cs WHERE cs.constructorId = c.constructorId AND cs.points = 0) = 2;
SELECT c.name FROM constructors c JOIN results r ON c.constructorId = r.constructorId WHERE r.rank = 1; 
SELECT COUNT(DISTINCT c.constructorId) AS french_constructors_count FROM constructors c JOIN results r ON c.constructorId = r.constructorId WHERE c.nationality = 'French' AND r.laps > 50; 
SELECT      (COUNT(res.time) / CAST(COUNT(*) AS FLOAT)) * 100 AS completion_percent FROM      drivers dri JOIN results res ON dri.driverId = res.driverId JOIN races rac ON res.raceId = rac.raceId WHERE      dri.nationality = 'Japanese' AND rac.year BETWEEN 2007 AND 2009; 
SELECT      YEAR(ra.date) AS Year,     AVG(         CAST(SUBSTRING(r.time, 1, CHARINDEX(':', r.time) - 1) AS INT) * 3600 +         CAST(SUBSTRING(r.time, CHARINDEX(':', r.time) + 1, CHARINDEX(':', r.time, CHARINDEX(':', r.time) + 1) - CHARINDEX(':', r.time) - 1) AS INT) * 60 +         CAST(REPLACE(SUBSTRING(r.time, CHARINDEX(':', r.time, CHARINDEX(':', r.time) + 1) + 1), '.', '') AS INT) / 1000.0     ) AS AverageTimeSeconds FROM      results r JOIN      races ra ON r.raceId = ra.raceId WHERE      YEAR(ra.date) < 1975     AND r.statusId IN (SELECT s.statusId FROM status s WHERE s.status = 'Finished') GROUP BY      YEAR(ra.date); 
SELECT drivers.forename, drivers.surname  FROM drivers  INNER JOIN results ON drivers.driverId = results.driverId  WHERE YEAR(dob) > 1975 AND rank = 2; 
SELECT COUNT(*) AS NumberOfItalianDrivers  FROM drivers d  LEFT JOIN results r ON d.driverId = r.driverId  WHERE d.nationality = 'Italian' AND r.time IS NULL; 
SELECT d.forename, d.surname  FROM drivers d  WHERE d.driverId IN (     SELECT r.driverId      FROM results r      WHERE r.fastestLapTime = (SELECT MIN(r2.fastestLapTime) FROM results r2) ); 
  SELECT fastestLap FROM results WHERE time = '1:34:50.616';
SELECT AVG(fastestLapSpeed) FROM results JOIN races ON races.raceId = results.raceId WHERE races.name = 'Spanish Grand Prix'; 
SELECT r.name, r.year FROM races AS r  JOIN results AS res ON r.raceId = res.raceId  WHERE res.milliseconds IS NOT NULL  GROUP BY r.raceId  ORDER BY MIN(res.milliseconds) ASC  LIMIT 1; 
SELECT      (COUNT(DISTINCT r.driverId) / COUNT(DISTINCT t.driverId)) * 100 AS percentage FROM      results r JOIN      drivers d ON r.driverId = d.driverId JOIN      races ra ON r.raceId = ra.raceId,     (         SELECT              DISTINCT driverId         FROM              results res         JOIN              races re ON res.raceId = re.raceId         WHERE              re.year BETWEEN 2000 AND 2005     ) t WHERE      ra.year BETWEEN 2000 AND 2005     AND YEAR(d.dob) < 1985     AND r.laps > 50; 
SELECT COUNT(*)  FROM drivers d JOIN lapTimes l ON d.driverId = l.driverId WHERE d.nationality = 'French' AND (     (CAST(SUBSTRING_INDEX(l.time, ':', 1) AS UNSIGNED) * 60 +       CAST(SUBSTRING_INDEX(l.time, ':', -1) AS DECIMAL(5,3))) < 120 ); 
  SELECT code FROM drivers WHERE nationality = 'America';
SELECT raceId FROM races WHERE year = 2009; 
  SELECT COUNT(DISTINCT driverId) FROM driverStandings WHERE raceId = 18;
SELECT COUNT(*) AS netherlands_count  FROM (     SELECT nationality      FROM drivers      ORDER BY dob DESC      LIMIT 3 ) AS top_youngest  WHERE nationality = 'Dutch'; 
SELECT `driverRef` FROM `drivers` WHERE `forename` = 'Robert' AND `surname` = 'Kubica'; 
SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND YEAR(dob) = 1980; 
  SELECT d.driverId, d.nationality, d.dob FROM drivers d JOIN (     SELECT driverId, MIN(time) AS min_time     FROM pitStops     GROUP BY driverId ) ps ON d.driverId = ps.driverId WHERE d.nationality = 'German' AND YEAR(d.dob) BETWEEN 1980 AND 1990 ORDER BY ps.min_time ASC LIMIT 3;
SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY dob ASC LIMIT 1; 
SELECT d.driverId, d.code  FROM drivers d  JOIN results r ON d.driverId = r.driverId  WHERE YEAR(d.dob) = 1971 AND r.fastestLapTime = (SELECT MIN(fastestLapTime) FROM results); 
  SELECT d.driverId, d.nationality, d.dob, MAX(ps.time) AS latest_time  FROM drivers d  JOIN pitStops ps ON d.driverId = ps.driverId  WHERE d.nationality = 'Spanish' AND YEAR(d.dob) < 1982  GROUP BY d.driverId  ORDER BY latest_time DESC  LIMIT 10;
SELECT r.year FROM races r JOIN results res ON r.raceId = res.raceId WHERE res.fastestLapTime = (     SELECT MIN(res2.fastestLapTime)      FROM results res2 ) GROUP BY r.year; 
SELECT r.year  FROM races r  JOIN (     SELECT raceId, MAX(time) AS max_time      FROM lapTimes      GROUP BY raceId ) lt ON r.raceId = lt.raceId  ORDER BY lt.max_time DESC  LIMIT 1; 
WITH FastestTimes AS (     SELECT          driverId,         MIN(time) as fastestTime     FROM          lapTimes     WHERE          lap = 1     GROUP BY          driverId ), RankedDrivers AS (     SELECT          driverId,         RANK() OVER (ORDER BY fastestTime ASC) as rank     FROM          FastestTimes ) SELECT      driverId FROM      RankedDrivers WHERE      rank <= 5 ORDER BY      rank ASC; 
SELECT COUNT(*) FROM results WHERE statusId = 2 AND time IS NOT NULL AND raceId > 50 AND raceId < 100; 
SELECT COUNT(*) FROM circuits WHERE country = 'Austria'; 
SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(*) DESC LIMIT 1; 
SELECT d.driverRef, d.nationality, d.dob  FROM drivers d  JOIN qualifying q ON d.driverId = q.driverId  WHERE q.raceId = 23 AND q.q2 IS NOT NULL; 
SELECT    YEAR(races.date) AS Year,   drivers.name AS DriverName,   races.name AS RaceName,   races.date AS RaceDateTime FROM    (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1) AS yd JOIN results ON yd.driverId = results.driverId JOIN races ON results.raceId = races.raceId WHERE races.date = (   SELECT MIN(races.date)    FROM races    JOIN results r2 ON races.raceId = r2.raceId    WHERE r2.driverId = yd.driverId ) LIMIT 1; 
SELECT COUNT(DISTINCT d.driverId) AS american_puncture_drivers_count FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN status s ON r.statusId = s.statusId WHERE d.nationality = 'American'   AND s.status = 'Puncture'; 
  SELECT c.url AS introduction_website, cs.points  FROM constructors c  JOIN constructorStandings cs ON c.constructorId = cs.constructorId  WHERE c.nationality = 'Italian'  ORDER BY cs.points DESC  LIMIT 1;
  SELECT c.url FROM constructors c INNER JOIN constructorStandings cs ON c.constructorId = cs.constructorId WHERE cs.wins = (SELECT MAX(wins) FROM constructorStandings);
SELECT driverId, MAX(time) FROM lapTimes  WHERE raceId = (SELECT raceId FROM races WHERE name = "French Grand Prix")  AND lap = 3; 
SELECT `raceId`, `milliseconds` FROM `lapTimes` WHERE `lap` = 1 ORDER BY `milliseconds` ASC LIMIT 1; 
SELECT      AVG(         CAST(SUBSTRING_INDEX(fastestLapTime, ':', 1) AS UNSIGNED) * 60 +         CAST(             REPLACE(                 SUBSTRING_INDEX(fastestLapTime, ':', -1), '.', ''             ) AS UNSIGNED         ) / 1000     ) AS average_fastest_lap_time_seconds FROM      races r JOIN      results res ON r.raceId = res.raceId WHERE      r.year = 2006      AND r.name = 'United States Grand Prix'; 
SELECT      d.driverId,     d.forename,     d.surname,     AVG(ps.duration) AS avg_pit_duration FROM      drivers d JOIN      pit_stops ps ON d.driverId = ps.driverId WHERE      d.nationality = 'German'     AND YEAR(d.dob) BETWEEN 1980 AND 1985 GROUP BY      d.driverId, d.forename, d.surname ORDER BY      avg_pit_duration ASC LIMIT 3; 
SELECT r.name AS race_name, r.year, res.time AS finish_time FROM races r LEFT JOIN results res ON r.raceId = res.raceId WHERE r.name = 'Canadian Grand Prix' AND r.year = 2008; 
  SELECT c.constructorRef AS `constructor reference name`, c.url AS website FROM constructors c JOIN results r ON c.constructorId = r.constructorId JOIN races ra ON r.raceId = ra.raceId WHERE ra.year = 2009 AND ra.name = 'Singapore Grand Prix' ORDER BY r.time DESC LIMIT 1;
  SELECT forename AS full_name, dob FROM drivers WHERE nationality = 'Austrian' AND YEAR(dob) BETWEEN 1981 AND 1991;
  SELECT CONCAT(forename, ' ', surname) AS full_name, url AS wiki_page_link, dob AS date_of_birth  FROM drivers  WHERE nationality = 'German' AND YEAR(dob) BETWEEN 1971 AND 1985  ORDER BY dob DESC;
SELECT name, country, lat, lng FROM circuits WHERE name = 'Hungaroring'; 
  SELECT c.name AS ConstructorName, c.nationality AS Nationality, SUM(cr.points) AS TotalPoints FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId WHERE cr.year BETWEEN 1980 AND 2010 GROUP BY c.constructorId ORDER BY TotalPoints DESC LIMIT 1;  SELECT c.name AS ConstructorName, c.nationality AS Nationality, MAX(cr.points) AS Score FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId WHERE cr.year BETWEEN 1980 AND 2010 GROUP BY c.constructorId ORDER BY Score DESC LIMIT 1;
  SELECT AVG(ds.points) AS average_score FROM driverStandings ds JOIN drivers d ON ds.driverId = d.driverId JOIN races r ON ds.raceId = r.raceId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND r.name = 'Turkish Grand Prix';  # Note: The result will be NULL because there are no records for the Turkish Grand Prix in the provided data.
WITH RECURSIVE YearRange AS (     SELECT 2000 AS year     UNION ALL     SELECT year + 1 FROM YearRange WHERE year < 2010 ) SELECT      (SUM(num_races) / COUNT(DISTINCT yr.year)) AS annual_average FROM YearRange yr LEFT JOIN races r ON YEAR(r.date) = yr.year WHERE yr.year BETWEEN 2000 AND 2010; 
SELECT nationality FROM drivers GROUP BY nationality HAVING COUNT(*) = (SELECT MAX(count) FROM (SELECT COUNT(*) as count FROM drivers GROUP BY nationality)); 
